[workspace]
members = [
    ".",
    "client/rust",
]
resolver = "2"

[workspace.dependencies]
# gRPC
prost = "0.13"
prost-types = "0.13"
tonic = "0.12"
tonic-health = "0.12"
tokio-stream = { version = "0.1", features = ["net"] }

# Async
tokio = { version = "1", features = ["full"] }
async-trait = "0.1"
futures = "0.3"

# Utilities
uuid = { version = "1", features = ["v4", "v5"] }
chrono = "0.4"
hex = "0.4"
thiserror = "2"

# HTTP client and serialization for external service calls
reqwest = { version = "0.12", features = ["json"] }
serde = { version = "1", features = ["derive"] }

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter", "json"] }

# Testing
cucumber = "0.21"

# HTTP server for mock services
axum = { version = "0.7", features = ["json"] }

# Storage (for projectors)
sqlx = { version = "0.8", features = ["runtime-tokio"] }
sqlx-postgres = { package = "sqlx", version = "0.8", features = ["runtime-tokio", "postgres"] }
sqlx-sqlite = { package = "sqlx", version = "0.8", features = ["runtime-tokio", "sqlite"] }
sea-query = "0.32"
sea-query-binder = { version = "0.7" }
sea-query-binder-postgres = { package = "sea-query-binder", version = "0.7", features = ["sqlx-postgres"] }
sea-query-binder-sqlite = { package = "sea-query-binder", version = "0.7", features = ["sqlx-sqlite"] }

# Local crates
angzarr = { path = "." }
angzarr-client = { path = "client/rust" }

[package]
name = "angzarr"
version = "0.1.0"
edition = "2021"
authors = ["Benjamin Abbitt"]
description = "Schema-first CQRS/ES framework for polyglot client logic"
license = "AGPL-3.0-only"

[features]
# Default: works out of box for local development
default = ["standalone"]

# =============================================================================
# Deployment Profiles (opinionated stacks)
# =============================================================================
# standalone: Local dev, no external deps
standalone = ["sqlite", "channel", "topology"]
# k8s: Generic Kubernetes with Postgres + RabbitMQ
k8s = ["postgres", "amqp", "topology", "otel"]
# gcp-cloudrun: GCP serverless with Cloud SQL + Pub/Sub + GCS
gcp-cloudrun = ["postgres", "pubsub", "gcs", "topology", "otel"]
# gcp-k8s: GCP Kubernetes with Bigtable + Pub/Sub + GCS
gcp-k8s = ["bigtable", "pubsub", "gcs", "topology", "otel"]
# aws-k8s: AWS Kubernetes with DynamoDB + SNS/SQS + S3
aws-k8s = ["dynamo", "sns-sqs", "s3", "topology", "otel"]

# =============================================================================
# Messaging Backends
# =============================================================================
amqp = ["dep:lapin", "dep:deadpool-lapin"]
kafka = ["dep:rdkafka"]
pubsub = ["dep:google-cloud-pubsub", "dep:google-cloud-auth", "dep:google-cloud-googleapis"]
sns-sqs = ["dep:aws-sdk-sns", "dep:aws-sdk-sqs", "dep:aws-config"]
channel = []  # In-memory event bus, no external deps

# =============================================================================
# Storage Backends
# =============================================================================
postgres = ["dep:sqlx", "dep:sea-query", "dep:sea-query-binder", "sqlx/postgres", "sqlx/migrate", "sqlx/uuid", "sea-query-binder/sqlx-postgres"]
sqlite = ["dep:sqlx", "dep:sea-query", "dep:sea-query-binder", "sqlx/sqlite", "sqlx/migrate", "sea-query-binder/sqlx-sqlite"]
redis = ["dep:redis"]
immudb = ["dep:sqlx", "dep:sea-query", "sqlx/postgres", "sqlx/uuid"]  # Uses pgsql wire protocol
bigtable = ["dep:bigtable_rs"]
dynamo = ["dep:aws-sdk-dynamodb", "dep:aws-config"]

# =============================================================================
# Payload Store Backends (claim check pattern)
# =============================================================================
gcs = ["dep:google-cloud-storage", "dep:google-cloud-auth"]
s3 = ["dep:aws-sdk-s3", "dep:aws-config"]

# =============================================================================
# Observability & Utilities
# =============================================================================
otel = ["dep:opentelemetry", "dep:opentelemetry_sdk", "dep:opentelemetry-otlp", "dep:opentelemetry-appender-tracing", "dep:tracing-opentelemetry"]
topology = ["dep:axum"]
lossy = ["dep:rand"]

# =============================================================================
# All Features (for CI/development)
# =============================================================================
full = ["standalone", "k8s", "gcp-cloudrun", "gcp-k8s", "aws-k8s", "kafka", "redis", "immudb", "lossy"]

[dependencies]
# Client library (proto types, extension traits, client implementations)
angzarr-client = { path = "client/rust" }

# gRPC
tonic = "0.12"
tonic-health = "0.12"
prost = "0.13"
prost-types = "0.13"
tokio-stream = { version = "0.1", features = ["net"] }
tower = "0.5"
tower-http = { version = "0.6", features = ["trace", "cors"] }
http = "1"
http-body = "1"
bytes = "1"
hyper-util = { version = "0.1", features = ["tokio"] }

# Async runtime
tokio = { version = "1", features = ["full"] }

# Storage - Query builder approach (like jOOQ) - optional for postgres/sqlite
sea-query = { version = "0.32", optional = true }
sea-query-binder = { version = "0.7", optional = true }
sqlx = { version = "0.8", features = ["runtime-tokio"], optional = true }

# Retry with backoff
backon = "1"

# HTTP client for external service calls
reqwest = { version = "0.12", features = ["json"] }

# Core utilities
uuid = { version = "1", features = ["v4", "v5"] }
async-trait = "0.1"
thiserror = "2"
futures = "0.3"
chrono = "0.4"
hex = "0.4"
serde_json = "1"

# Protobuf reflection (for logging projector)
prost-reflect = { version = "0.14", features = ["serde"] }

# Logging/Tracing
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# OpenTelemetry (optional, feature-gated)
opentelemetry = { version = "0.27", optional = true }
opentelemetry_sdk = { version = "0.27", features = ["rt-tokio"], optional = true }
opentelemetry-otlp = { version = "0.27", features = ["tonic", "metrics", "logs"], optional = true }
opentelemetry-appender-tracing = { version = "0.27", optional = true }
tracing-opentelemetry = { version = "0.28", optional = true }

# Configuration
config = "0.14"
serde = { version = "1", features = ["derive"] }
serde_yaml = "0.9"
base64 = "0.22"

# AMQP/RabbitMQ (optional)
lapin = { version = "2", optional = true }
deadpool-lapin = { version = "0.12", optional = true }

# Redis (optional)
redis = { version = "0.27", features = ["aio", "connection-manager", "tokio-comp"], optional = true }

# Kafka (optional)
rdkafka = { version = "0.36", features = ["cmake-build", "ssl", "sasl"], optional = true }

# Google Pub/Sub (optional)
google-cloud-pubsub = { version = "0.29", optional = true }
google-cloud-auth = { version = "0.19", optional = true }
google-cloud-googleapis = { version = "0.15", optional = true }

# AWS SNS/SQS (optional)
aws-sdk-sns = { version = "1", optional = true }
aws-sdk-sqs = { version = "1", optional = true }
aws-config = { version = "1", optional = true }

# AWS S3 (optional, for payload store)
aws-sdk-s3 = { version = "1", optional = true }

# AWS DynamoDB (optional, for event store)
aws-sdk-dynamodb = { version = "1", optional = true }

# Google Cloud Storage (optional, for payload store)
google-cloud-storage = { version = "0.22", optional = true }

# Google Cloud Bigtable (optional, for event store)
bigtable_rs = { version = "0.2", optional = true }

# Random (for lossy testing bus)
rand = { version = "0.9", optional = true }

# HTTP framework (for topology REST API)
axum = { version = "0.7", features = ["json"], optional = true }

# Kubernetes API (for gateway service discovery)
kube = { version = "0.98", features = ["runtime", "client"] }
k8s-openapi = { version = "0.24", features = ["v1_29"] }

# DNS resolution (for SRV-based service discovery)
hickory-resolver = { version = "0.24", features = ["tokio-runtime"] }
sha2 = "0.10.9"

# Unix process management (for standalone orchestrator)
[target.'cfg(unix)'.dependencies]
nix = { version = "0.29", features = ["signal", "process", "fs", "user"] }

[build-dependencies]
tonic-build = "0.12"

[[bin]]
name = "angzarr-aggregate"
path = "src/bin/angzarr_aggregate.rs"

[[bin]]
name = "angzarr-projector"
path = "src/bin/angzarr_projector.rs"

[[bin]]
name = "angzarr-saga"
path = "src/bin/angzarr_saga.rs"

[[bin]]
name = "angzarr-process-manager"
path = "src/bin/angzarr_process_manager.rs"

[[bin]]
name = "angzarr-log"
path = "src/bin/angzarr_log.rs"

[[bin]]
name = "angzarr-stream"
path = "src/bin/angzarr_stream.rs"

[[bin]]
name = "angzarr-standalone"
path = "src/bin/angzarr_standalone.rs"
required-features = ["standalone"]

[[bin]]
name = "angzarr-event-projector"
path = "src/bin/angzarr_event_projector.rs"
required-features = ["postgres"]

[[bin]]
name = "angzarr-topology"
path = "src/bin/angzarr_topology.rs"
required-features = ["topology"]

[[bin]]
name = "angzarr-upcaster"
path = "src/bin/angzarr_upcaster.rs"

[dev-dependencies]
tokio-test = "0.4"
tempfile = "3"
cucumber = "0.21"
futures = "0.3"
serial_test = "3"
testcontainers = "0.23"
hex = "0.4"

[[test]]
name = "interfaces"
path = "tests/interfaces/main.rs"
harness = false

[[test]]
name = "storage_redis"
required-features = ["redis"]

[[test]]
name = "storage_postgres"
required-features = ["postgres"]

[[test]]
name = "storage_sqlite"
required-features = ["sqlite"]

[[test]]
name = "storage_immudb"
required-features = ["immudb"]

# === Build Profiles ===

# Dev profile - optimized for size to keep disk usage sane
[profile.dev]
opt-level = "z"
debug = 0
strip = true
incremental = true

# Container dev profile - optimized for size, no incremental
# Usage: cargo build --profile container-dev
[profile.container-dev]
inherits = "dev"
incremental = false

# Test profile - optimized for size
# Usage: cargo test (automatically used)
[profile.test]
opt-level = "z"
debug = 0
strip = true
incremental = true

# Release profile - slow compilation, fast runtime (for production)
[profile.release]
opt-level = "z"     # Optimize for size
lto = "fat"         # Maximum link-time optimization
codegen-units = 1   # Single codegen unit for best optimization
strip = true        # Strip symbols for smaller binaries
panic = "abort"     # Abort on panic (smaller binaries, no unwinding)

# Production profile - maximum optimization with all features
# Usage: cargo build --profile production --features full
[profile.production]
inherits = "release"
lto = "fat"
codegen-units = 1
strip = true
panic = "abort"
opt-level = 3
