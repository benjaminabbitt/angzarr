# Claude Development Rules for Angzarr

## Core Principles

1. **No Standard Library**: This is kernel code - ALWAYS use `#![no_std]`
2. **Safety First**: Minimize `unsafe`, document all safety invariants
3. **Binary Compatibility**: Maintain C ABI compatibility at all times
4. **Test-Driven Development**: Write tests before implementation
5. **No Innovation**: Only replace C with functionally equivalent Rust
6. **ABI Verification**: Always run `just check-abi` before committing
7. **Robustness Over Performance**: At this stage, prioritize correctness, error handling, and robustness over optimization
8. **Event-Driven Architecture**: Use service-oriented and event-driven systems where feasible and compatible with binary compatibility requirements
9. **License Compliance**: Check and document licensing for all copied code - MUST be GPL-2.0 compatible
10. **Target Platforms**: Support x86-64, ARM64, and RISC-V (risc5) architectures
11. **Linux Test Translation**: Import and translate all relevant Linux kernel tests, maintaining C expectations while allowing implementation variance
12. **Test Traceability is King**: Every test must be traceable to its Linux source - document file, function, and line number for full auditability
13. **Linux Kernel Business Logic**: For all existing and new functionality, evaluate business logic as implemented in Linux kernel - replicate logic exactly unless Rust has demonstrably better patterns

## Code Review Personas

When reviewing code, consider feedback from these expert perspectives:

### 1. Expert Rust Systems Programmer
**Focus Areas:**
- Proper use of Rust safety features and idioms
- Efficient use of zero-cost abstractions
- Correct use of `unsafe` blocks with proper documentation
- Memory safety and lifetime management
- Optimal use of Rust type system for compile-time guarantees
- Performance implications of Rust patterns
- Adherence to Rust API guidelines

### 2. Linux Kernel Developer
**Focus Areas:**
- Correctness of Linux kernel semantics
- Proper implementation of kernel data structures and algorithms
- Understanding of kernel locking and synchronization patterns
- Knowledge of kernel memory management and allocation patterns
- Familiarity with kernel subsystem interactions
- Awareness of kernel performance characteristics
- Compliance with kernel coding practices

### 3. Software Architect
**Focus Areas:**
- System-level design and component boundaries
- Maintainability and extensibility of architecture
- Appropriate abstraction levels
- Module coupling and cohesion
- Long-term technical debt implications
- Scalability of design decisions
- Consistency across codebase
- Event-driven and service-oriented patterns

### 4. Embedded Systems Expert
**Focus Areas:**
- Resource-constrained environment considerations
- No standard library (`no_std`) compliance
- Memory footprint optimization
- Deterministic behavior and timing
- Hardware interaction patterns
- Boot-time and initialization sequences
- Interrupt handling and real-time concerns
- Power management implications

**Review Process:** Consider all four perspectives when evaluating code changes. Each brings critical domain expertise that ensures Angzarr is correct, safe, maintainable, and suitable for embedded/kernel environments.

## Communication Guidelines

1. **Skip Flattery**: No unnecessary praise or validation - focus on technical accuracy
2. **Ask Before Significant Work**: When requirements are unclear or multiple approaches exist, ask questions first
3. **Be Concise**: Short, technical responses - this is CLI output
4. **Professional Objectivity**: Prioritize facts over agreement
5. **Be Robust**: Handle errors gracefully, validate inputs, consider edge cases, design for failure scenarios

## Code Requirements

### No Standard Library

- All crates MUST have `#![no_std]` at the top
- NO use of `std::` - use `core::` instead
- NO heap allocations in tests unless explicitly mocking kernel allocator
- Tests run in userspace with std, but core code is `no_std`

### Safety Guidelines

```rust
// ✅ GOOD: Minimal unsafe, well-documented
/// # Safety
/// ptr must be valid and properly aligned
pub unsafe fn foo(ptr: *mut T) { ... }

// ❌ BAD: Undocumented unsafe
pub unsafe fn bar(ptr: *mut T) { ... }
```

### Binary Compatibility

- All FFI types MUST use `#[repr(C)]`
- All FFI functions MUST use `extern "C"`
- All exports MUST use `#[no_mangle]`
- Structure layouts MUST match Linux kernel exactly

```rust
// ✅ GOOD
#[repr(C)]
pub struct ListHead {
    pub next: *mut ListHead,
    pub prev: *mut ListHead,
}

#[no_mangle]
pub extern "C" fn list_add(new: *mut ListHead, head: *mut ListHead) { ... }

// ❌ BAD
pub struct ListHead { ... }  // Missing #[repr(C)]
pub fn list_add(...) { ... }  // Not extern "C"
```

### Testing Requirements

- Every function needs unit tests
- Use `#[cfg(test)]` for test modules
- Tests can use `std` (they run in userspace)
- Gherkin tests for end-user functionality
- Property-based tests for data structures

### Error Handling

- Use `Result<T, KernelError>` for fallible operations
- Never panic in kernel code (use `panic = "abort"`)
- Document all error conditions

### Concurrency

- All shared mutable state requires synchronization
- Document lock ordering to prevent deadlocks
- Use type system to enforce Send/Sync bounds

## File Organization

```
crate-name/
├── Cargo.toml
├── src/
│   ├── lib.rs        # Crate root with #![no_std]
│   ├── module1.rs    # Implementation
│   └── module2.rs
└── tests/            # Integration tests (can use std)
```

## Commit Guidelines

1. Format code: `just fmt`
2. Run linter: `just lint`
3. Run tests: `just test`
4. All CI must pass: `just ci`
5. Commit messages: Clear, concise, imperative mood

## Performance

- Release builds use LTO
- Profile critical paths
- No unnecessary allocations
- Use inline hints for hot paths: `#[inline]`

## Documentation

- Document all public APIs
- Include safety requirements for unsafe functions
- Add examples where helpful
- Link to Linux kernel equivalents

## Code Review Checklist

- [ ] `#![no_std]` present in lib.rs
- [ ] All unsafe blocks documented
- [ ] FFI types use `#[repr(C)]`
- [ ] Tests written and passing
- [ ] Clippy warnings addressed
- [ ] Code formatted with rustfmt
- [ ] No panics in kernel code

## Dependencies

- Minimize external dependencies
- Prefer `no_std` compatible crates
- Audit all dependencies for safety
- Document why each dependency is needed

## Anti-Patterns to Avoid

❌ Using `std::` in kernel code
❌ Undocumented `unsafe` blocks
❌ Panics in release builds
❌ Missing `#[repr(C)]` on FFI types
❌ Uninitialized memory without documentation
❌ Global mutable state without synchronization
❌ Implementing features not in Linux kernel
❌ Copying code without checking license compatibility

## License Compliance

### Project License

**Angzarr is licensed under GPL-2.0** (same as Linux kernel)

### When Copying Code

**ALWAYS check and document licensing when copying code from:**

1. **Linux Kernel**
   - License: GPL-2.0
   - ✅ Compatible - Can copy
   - Document source file and commit hash
   - Maintain copyright headers

2. **BSD Kernels (FreeBSD/OpenBSD/NetBSD)**
   - License: BSD-2-Clause or BSD-3-Clause
   - ✅ Compatible with GPL-2.0
   - Document source and preserve BSD copyright
   - Note: Code becomes GPL-2.0 in Angzarr

3. **Rust Crates**
   - Check Cargo.toml for license
   - ✅ Compatible: MIT, Apache-2.0, BSD-*
   - ❌ Incompatible: GPL-3.0, AGPL, proprietary
   - Document in THIRD_PARTY_LICENSES.md

4. **Other Sources**
   - Always verify license
   - If unclear, DON'T copy
   - When in doubt, reimplement from spec

### Documentation Requirements

**For ALL copied code, add header:**

```rust
// SPDX-License-Identifier: GPL-2.0
//
// Portions derived from Linux kernel:
//   File: kernel/sched/core.c
//   Commit: abc123def456
//   Copyright: (C) 2024 Linux Kernel Authors
//
// Adapted to Rust for Angzarr kernel
```

**For BSD-derived code:**

```rust
// SPDX-License-Identifier: GPL-2.0
//
// Portions derived from FreeBSD:
//   File: sys/kern/kern_mutex.c
//   Copyright: (C) 2024 The FreeBSD Foundation
//   Original License: BSD-2-Clause
//
// Adapted to Rust for Angzarr kernel
// (BSD code becomes GPL-2.0 when incorporated)
```

### License Compatibility Matrix

| Source License | Compatible? | Notes |
|---------------|-------------|-------|
| GPL-2.0 | ✅ Yes | Same license |
| GPL-2.0+ | ✅ Yes | Can use as GPL-2.0 |
| LGPL-2.1 | ✅ Yes | Can incorporate |
| MIT | ✅ Yes | Becomes GPL-2.0 |
| Apache-2.0 | ✅ Yes | Becomes GPL-2.0 |
| BSD-2/3-Clause | ✅ Yes | Becomes GPL-2.0 |
| GPL-3.0 | ❌ No | Incompatible |
| AGPL | ❌ No | Incompatible |
| Proprietary | ❌ No | Cannot use |
| Unknown | ❌ No | Assume incompatible |

### Verification Checklist

Before copying code:

- [ ] Identify source file and project
- [ ] Check license (look for SPDX, LICENSE, COPYING)
- [ ] Verify GPL-2.0 compatibility
- [ ] Document source in code header
- [ ] Add to THIRD_PARTY_LICENSES.md if external
- [ ] Preserve original copyright notices
- [ ] Add SPDX-License-Identifier: GPL-2.0

### THIRD_PARTY_LICENSES.md

Maintain `THIRD_PARTY_LICENSES.md` with:

```markdown
# Third-Party Licenses

## Linux Kernel Code

- **License**: GPL-2.0
- **Copyright**: Linux Kernel Authors
- **Source**: https://git.kernel.org/
- **Files derived**:
  - angzarr-sync/src/spinlock.rs (from kernel/locking/spinlock.c)
  - angzarr-mm/src/slub.rs (from mm/slub.c)

## FreeBSD Code

- **License**: BSD-2-Clause (incorporated as GPL-2.0)
- **Copyright**: The FreeBSD Foundation
- **Source**: https://github.com/freebsd/freebsd-src
- **Files derived**:
  - angzarr-sync/src/mutex.rs (from sys/kern/kern_mutex.c)

## Rust Crates

### spin v0.9.8
- **License**: MIT
- **Copyright**: Mathijs van de Nes and contributors
- **Usage**: Reference for spinlock implementation
- **Files**: angzarr-sync/src/spinlock.rs (concepts only, reimplemented)
```

### Automated Checking

Future: Add to CI pipeline:

```bash
# Check all Rust files have SPDX headers
just check-licenses

# Scan for potential license violations
cargo deny check licenses
```

### When Uncertain

1. Check SPDX.org for license info
2. Consult https://www.gnu.org/licenses/license-list.html
3. If still uncertain, reimplement from specification/algorithm description
4. Document uncertainty and seek review

## Linux Module Testing (Future Work)

### Isolated Modules for Testing

When kernel is more mature, test with isolated Linux modules:

**Good Candidates (minimal dependencies):**
- `dummy.ko` - Dummy network driver
- `loop.ko` - Loop block device
- `configfs.ko` - Configuration filesystem
- `tun.ko` - TUN/TAP driver
- `crypto_user.ko` - Crypto API

**Testing Approach:**
1. Load module with `insmod`
2. Verify module initialization
3. Test basic functionality
4. Verify cleanup on `rmmod`
5. Check for memory leaks/crashes

**Status:** Not feasible at current stage (Phase 0/1)
- Need full memory management (Phase 2)
- Need device driver framework (Phase 9)
- Need module loading infrastructure
- Target: Phase 10+ (after core subsystems)

### Module Loading Test Plan

```bash
# Future test script (scripts/test-module.sh)
#!/bin/bash
# Test isolated Linux module compatibility
insmod /path/to/test.ko
test-functionality
rmmod test
dmesg | grep -i error
```

**Document module test results in:** `MODULE_COMPAT_TESTS.md`

## Linux Test Translation

### Requirements

**For every subsystem implemented, translate corresponding Linux kernel tests:**

1. **Source Identification**
   - `lib/test_*.c` - Kernel library unit tests
   - `lib/*_test.c` - Subsystem-specific tests
   - `tools/testing/selftests/` - Self-tests (future)
   - Individual subsystem test code (e.g., in `kernel/`, `mm/`)

2. **Translation Process**
   - Locate Linux test file (e.g., `lib/test_list.c`)
   - Translate test logic to Rust
   - Place in appropriate crate's `#[cfg(test)]` module
   - Keep C expectations identical
   - Allow implementation variance if same result achieved
   - Document source file and line numbers

3. **Test Organization**
   - Place tests in source crate (standard Rust practice)
   - Use `#[cfg(test)] mod tests` or `#[cfg(test)] mod linux_tests`
   - Group by Linux test file for traceability

4. **Documentation**
   - Header comment referencing Linux source
   - Test name maps to Linux test function
   - Document any implementation differences
   - Track in `LINUX_TEST_MAPPING.md`

### Example Translation

```rust
// SPDX-License-Identifier: GPL-2.0
//
// Tests derived from Linux kernel:
//   File: lib/test_list.c
//   Copyright: (C) Linux Kernel Authors
//
// Translated to Rust for Angzarr

#[cfg(test)]
mod linux_tests {
    use super::*;

    /// Translated from test_list_add() in lib/test_list.c:25
    #[test]
    fn test_list_add() {
        // Test logic translated from C
        let mut head = list_head::new();
        unsafe {
            head.init();
            // ... rest of test
        }
    }
}
```

### Traceability

Every translated test must document:
- Source file path in Linux kernel
- Original function name
- Line number (approximate, for reference)
- Any implementation differences
- Expected behavior (must match C)

### Mapping File

Maintain `LINUX_TEST_MAPPING.md` with:

| Angzarr Test | Linux Source | Status | Notes |
|--------------|--------------|--------|-------|
| `angzarr-list::tests::test_list_add` | `lib/test_list.c:25` | ✅ | Direct translation |
| `angzarr-list::tests::test_list_del` | `lib/test_list.c:45` | ✅ | Direct translation |

### Verification

- Translated tests must pass
- Behavior must match Linux expectations
- Edge cases from C tests preserved
- Performance tests adapted to Rust benchmarks

### C Data Structures for Test I/O

**CRITICAL REQUIREMENT**: Use C-compatible data structures for test input and output

- **Input**: Tests must operate on C-compatible structures with `#[repr(C)]`
- **Output**: Tests must verify C-compatible structure state
- **Evaluation**: Rust logic can be used for test evaluation
- **Purpose**: Ensures binary-level compatibility, not just behavioral compatibility

**Why This Matters:**
- Verifies actual memory layout matches Linux kernel
- Catches alignment and padding issues
- Proves Rust implementation is drop-in replacement for C
- Tests the actual FFI boundary that C code will use

**Example:**

```rust
#[cfg(test)]
mod linux_tests {
    use super::*;
    use core::ptr;

    /// Translated from test_list_add() in lib/test_list.c:25
    #[test]
    fn test_list_add() {
        // Input: C data structure (matches Linux kernel exactly)
        let mut head = list_head {
            next: ptr::null_mut(),
            prev: ptr::null_mut(),
        };
        let mut entry = list_head {
            next: ptr::null_mut(),
            prev: ptr::null_mut(),
        };

        // Evaluation: Rust test logic calling C-compatible functions
        unsafe {
            INIT_LIST_HEAD(&mut head);
            list_add(&mut entry, &mut head);
        }

        // Output: Verify C structure state (binary-level verification)
        unsafe {
            assert_eq!(head.next, &mut entry as *mut _);
            assert_eq!((*head.next).prev, &mut head as *mut _);
            assert!(!list_empty(&head));
        }
    }
}
```

**Compile and Run C Tests for Comparison:**

Where possible, compile the original Linux C test and compare:
1. Pull in `lib/test_list.c` from Linux kernel
2. Compile C test with same input data
3. Compare C output to Rust output
4. Document any differences (there should be none)

This dual-validation approach ensures:
- Rust behavior matches C behavior exactly
- Memory layouts are identical
- No subtle differences in edge cases

## When in Doubt

1. Check Linux kernel implementation
2. Consult MIGRATION_STRATEGY.md
3. Run ABI compatibility tests: `just check-abi`
4. Write tests first
5. Document safety invariants
6. Ask for review
7. Check LINUX_TEST_MAPPING.md for test coverage
