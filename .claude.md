# Claude Development Rules for Angzarr

## Core Principles

1. **No Standard Library**: This is kernel code - ALWAYS use `#![no_std]`
2. **Safety First**: Minimize `unsafe`, document all safety invariants
3. **Binary Compatibility**: Maintain C ABI compatibility at all times
4. **Test-Driven Development**: Write tests before implementation
5. **No Innovation**: Only replace C with functionally equivalent Rust

## Code Requirements

### No Standard Library

- All crates MUST have `#![no_std]` at the top
- NO use of `std::` - use `core::` instead
- NO heap allocations in tests unless explicitly mocking kernel allocator
- Tests run in userspace with std, but core code is `no_std`

### Safety Guidelines

```rust
// ✅ GOOD: Minimal unsafe, well-documented
/// # Safety
/// ptr must be valid and properly aligned
pub unsafe fn foo(ptr: *mut T) { ... }

// ❌ BAD: Undocumented unsafe
pub unsafe fn bar(ptr: *mut T) { ... }
```

### Binary Compatibility

- All FFI types MUST use `#[repr(C)]`
- All FFI functions MUST use `extern "C"`
- All exports MUST use `#[no_mangle]`
- Structure layouts MUST match Linux kernel exactly

```rust
// ✅ GOOD
#[repr(C)]
pub struct ListHead {
    pub next: *mut ListHead,
    pub prev: *mut ListHead,
}

#[no_mangle]
pub extern "C" fn list_add(new: *mut ListHead, head: *mut ListHead) { ... }

// ❌ BAD
pub struct ListHead { ... }  // Missing #[repr(C)]
pub fn list_add(...) { ... }  // Not extern "C"
```

### Testing Requirements

- Every function needs unit tests
- Use `#[cfg(test)]` for test modules
- Tests can use `std` (they run in userspace)
- Gherkin tests for end-user functionality
- Property-based tests for data structures

### Error Handling

- Use `Result<T, KernelError>` for fallible operations
- Never panic in kernel code (use `panic = "abort"`)
- Document all error conditions

### Concurrency

- All shared mutable state requires synchronization
- Document lock ordering to prevent deadlocks
- Use type system to enforce Send/Sync bounds

## File Organization

```
crate-name/
├── Cargo.toml
├── src/
│   ├── lib.rs        # Crate root with #![no_std]
│   ├── module1.rs    # Implementation
│   └── module2.rs
└── tests/            # Integration tests (can use std)
```

## Commit Guidelines

1. Format code: `just fmt`
2. Run linter: `just lint`
3. Run tests: `just test`
4. All CI must pass: `just ci`
5. Commit messages: Clear, concise, imperative mood

## Performance

- Release builds use LTO
- Profile critical paths
- No unnecessary allocations
- Use inline hints for hot paths: `#[inline]`

## Documentation

- Document all public APIs
- Include safety requirements for unsafe functions
- Add examples where helpful
- Link to Linux kernel equivalents

## Code Review Checklist

- [ ] `#![no_std]` present in lib.rs
- [ ] All unsafe blocks documented
- [ ] FFI types use `#[repr(C)]`
- [ ] Tests written and passing
- [ ] Clippy warnings addressed
- [ ] Code formatted with rustfmt
- [ ] No panics in kernel code

## Dependencies

- Minimize external dependencies
- Prefer `no_std` compatible crates
- Audit all dependencies for safety
- Document why each dependency is needed

## Anti-Patterns to Avoid

❌ Using `std::` in kernel code
❌ Undocumented `unsafe` blocks
❌ Panics in release builds
❌ Missing `#[repr(C)]` on FFI types
❌ Uninitialized memory without documentation
❌ Global mutable state without synchronization
❌ Implementing features not in Linux kernel

## When in Doubt

1. Check Linux kernel implementation
2. Consult MIGRATION_STRATEGY.md
3. Write tests first
4. Document safety invariants
5. Ask for review
