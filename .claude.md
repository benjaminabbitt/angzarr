# Claude Development Rules for Angzarr

## Core Principles

1. **No Standard Library**: This is kernel code - ALWAYS use `#![no_std]`
2. **Safety First**: Minimize `unsafe`, document all safety invariants
3. **Binary Compatibility**: Maintain C ABI compatibility at all times
4. **Test-Driven Development**: Write tests before implementation
5. **No Innovation**: Only replace C with functionally equivalent Rust
6. **ABI Verification**: Always run `just check-abi` before committing
7. **Robustness Over Performance**: At this stage, prioritize correctness, error handling, and robustness over optimization
8. **Event-Driven Architecture**: Use service-oriented and event-driven systems where feasible and compatible with binary compatibility requirements
9. **License Compliance**: Check and document licensing for all copied code - MUST be GPL-2.0 compatible
10. **Target Platforms**: Support x86-64, ARM64, and RISC-V (risc5) architectures

## Communication Guidelines

1. **Skip Flattery**: No unnecessary praise or validation - focus on technical accuracy
2. **Ask Before Significant Work**: When requirements are unclear or multiple approaches exist, ask questions first
3. **Be Concise**: Short, technical responses - this is CLI output
4. **Professional Objectivity**: Prioritize facts over agreement
5. **Be Robust**: Handle errors gracefully, validate inputs, consider edge cases, design for failure scenarios

## Code Requirements

### No Standard Library

- All crates MUST have `#![no_std]` at the top
- NO use of `std::` - use `core::` instead
- NO heap allocations in tests unless explicitly mocking kernel allocator
- Tests run in userspace with std, but core code is `no_std`

### Safety Guidelines

```rust
// ✅ GOOD: Minimal unsafe, well-documented
/// # Safety
/// ptr must be valid and properly aligned
pub unsafe fn foo(ptr: *mut T) { ... }

// ❌ BAD: Undocumented unsafe
pub unsafe fn bar(ptr: *mut T) { ... }
```

### Binary Compatibility

- All FFI types MUST use `#[repr(C)]`
- All FFI functions MUST use `extern "C"`
- All exports MUST use `#[no_mangle]`
- Structure layouts MUST match Linux kernel exactly

```rust
// ✅ GOOD
#[repr(C)]
pub struct ListHead {
    pub next: *mut ListHead,
    pub prev: *mut ListHead,
}

#[no_mangle]
pub extern "C" fn list_add(new: *mut ListHead, head: *mut ListHead) { ... }

// ❌ BAD
pub struct ListHead { ... }  // Missing #[repr(C)]
pub fn list_add(...) { ... }  // Not extern "C"
```

### Testing Requirements

- Every function needs unit tests
- Use `#[cfg(test)]` for test modules
- Tests can use `std` (they run in userspace)
- Gherkin tests for end-user functionality
- Property-based tests for data structures

### Error Handling

- Use `Result<T, KernelError>` for fallible operations
- Never panic in kernel code (use `panic = "abort"`)
- Document all error conditions

### Concurrency

- All shared mutable state requires synchronization
- Document lock ordering to prevent deadlocks
- Use type system to enforce Send/Sync bounds

## File Organization

```
crate-name/
├── Cargo.toml
├── src/
│   ├── lib.rs        # Crate root with #![no_std]
│   ├── module1.rs    # Implementation
│   └── module2.rs
└── tests/            # Integration tests (can use std)
```

## Commit Guidelines

1. Format code: `just fmt`
2. Run linter: `just lint`
3. Run tests: `just test`
4. All CI must pass: `just ci`
5. Commit messages: Clear, concise, imperative mood

## Performance

- Release builds use LTO
- Profile critical paths
- No unnecessary allocations
- Use inline hints for hot paths: `#[inline]`

## Documentation

- Document all public APIs
- Include safety requirements for unsafe functions
- Add examples where helpful
- Link to Linux kernel equivalents

## Code Review Checklist

- [ ] `#![no_std]` present in lib.rs
- [ ] All unsafe blocks documented
- [ ] FFI types use `#[repr(C)]`
- [ ] Tests written and passing
- [ ] Clippy warnings addressed
- [ ] Code formatted with rustfmt
- [ ] No panics in kernel code

## Dependencies

- Minimize external dependencies
- Prefer `no_std` compatible crates
- Audit all dependencies for safety
- Document why each dependency is needed

## Anti-Patterns to Avoid

❌ Using `std::` in kernel code
❌ Undocumented `unsafe` blocks
❌ Panics in release builds
❌ Missing `#[repr(C)]` on FFI types
❌ Uninitialized memory without documentation
❌ Global mutable state without synchronization
❌ Implementing features not in Linux kernel
❌ Copying code without checking license compatibility

## License Compliance

### Project License

**Angzarr is licensed under GPL-2.0** (same as Linux kernel)

### When Copying Code

**ALWAYS check and document licensing when copying code from:**

1. **Linux Kernel**
   - License: GPL-2.0
   - ✅ Compatible - Can copy
   - Document source file and commit hash
   - Maintain copyright headers

2. **BSD Kernels (FreeBSD/OpenBSD/NetBSD)**
   - License: BSD-2-Clause or BSD-3-Clause
   - ✅ Compatible with GPL-2.0
   - Document source and preserve BSD copyright
   - Note: Code becomes GPL-2.0 in Angzarr

3. **Rust Crates**
   - Check Cargo.toml for license
   - ✅ Compatible: MIT, Apache-2.0, BSD-*
   - ❌ Incompatible: GPL-3.0, AGPL, proprietary
   - Document in THIRD_PARTY_LICENSES.md

4. **Other Sources**
   - Always verify license
   - If unclear, DON'T copy
   - When in doubt, reimplement from spec

### Documentation Requirements

**For ALL copied code, add header:**

```rust
// SPDX-License-Identifier: GPL-2.0
//
// Portions derived from Linux kernel:
//   File: kernel/sched/core.c
//   Commit: abc123def456
//   Copyright: (C) 2024 Linux Kernel Authors
//
// Adapted to Rust for Angzarr kernel
```

**For BSD-derived code:**

```rust
// SPDX-License-Identifier: GPL-2.0
//
// Portions derived from FreeBSD:
//   File: sys/kern/kern_mutex.c
//   Copyright: (C) 2024 The FreeBSD Foundation
//   Original License: BSD-2-Clause
//
// Adapted to Rust for Angzarr kernel
// (BSD code becomes GPL-2.0 when incorporated)
```

### License Compatibility Matrix

| Source License | Compatible? | Notes |
|---------------|-------------|-------|
| GPL-2.0 | ✅ Yes | Same license |
| GPL-2.0+ | ✅ Yes | Can use as GPL-2.0 |
| LGPL-2.1 | ✅ Yes | Can incorporate |
| MIT | ✅ Yes | Becomes GPL-2.0 |
| Apache-2.0 | ✅ Yes | Becomes GPL-2.0 |
| BSD-2/3-Clause | ✅ Yes | Becomes GPL-2.0 |
| GPL-3.0 | ❌ No | Incompatible |
| AGPL | ❌ No | Incompatible |
| Proprietary | ❌ No | Cannot use |
| Unknown | ❌ No | Assume incompatible |

### Verification Checklist

Before copying code:

- [ ] Identify source file and project
- [ ] Check license (look for SPDX, LICENSE, COPYING)
- [ ] Verify GPL-2.0 compatibility
- [ ] Document source in code header
- [ ] Add to THIRD_PARTY_LICENSES.md if external
- [ ] Preserve original copyright notices
- [ ] Add SPDX-License-Identifier: GPL-2.0

### THIRD_PARTY_LICENSES.md

Maintain `THIRD_PARTY_LICENSES.md` with:

```markdown
# Third-Party Licenses

## Linux Kernel Code

- **License**: GPL-2.0
- **Copyright**: Linux Kernel Authors
- **Source**: https://git.kernel.org/
- **Files derived**:
  - angzarr-sync/src/spinlock.rs (from kernel/locking/spinlock.c)
  - angzarr-mm/src/slub.rs (from mm/slub.c)

## FreeBSD Code

- **License**: BSD-2-Clause (incorporated as GPL-2.0)
- **Copyright**: The FreeBSD Foundation
- **Source**: https://github.com/freebsd/freebsd-src
- **Files derived**:
  - angzarr-sync/src/mutex.rs (from sys/kern/kern_mutex.c)

## Rust Crates

### spin v0.9.8
- **License**: MIT
- **Copyright**: Mathijs van de Nes and contributors
- **Usage**: Reference for spinlock implementation
- **Files**: angzarr-sync/src/spinlock.rs (concepts only, reimplemented)
```

### Automated Checking

Future: Add to CI pipeline:

```bash
# Check all Rust files have SPDX headers
just check-licenses

# Scan for potential license violations
cargo deny check licenses
```

### When Uncertain

1. Check SPDX.org for license info
2. Consult https://www.gnu.org/licenses/license-list.html
3. If still uncertain, reimplement from specification/algorithm description
4. Document uncertainty and seek review

## Linux Module Testing (Future Work)

### Isolated Modules for Testing

When kernel is more mature, test with isolated Linux modules:

**Good Candidates (minimal dependencies):**
- `dummy.ko` - Dummy network driver
- `loop.ko` - Loop block device
- `configfs.ko` - Configuration filesystem
- `tun.ko` - TUN/TAP driver
- `crypto_user.ko` - Crypto API

**Testing Approach:**
1. Load module with `insmod`
2. Verify module initialization
3. Test basic functionality
4. Verify cleanup on `rmmod`
5. Check for memory leaks/crashes

**Status:** Not feasible at current stage (Phase 0/1)
- Need full memory management (Phase 2)
- Need device driver framework (Phase 9)
- Need module loading infrastructure
- Target: Phase 10+ (after core subsystems)

### Module Loading Test Plan

```bash
# Future test script (scripts/test-module.sh)
#!/bin/bash
# Test isolated Linux module compatibility
insmod /path/to/test.ko
test-functionality
rmmod test
dmesg | grep -i error
```

**Document module test results in:** `MODULE_COMPAT_TESTS.md`

## When in Doubt

1. Check Linux kernel implementation
2. Consult MIGRATION_STRATEGY.md
3. Run ABI compatibility tests: `just check-abi`
4. Write tests first
5. Document safety invariants
6. Ask for review
