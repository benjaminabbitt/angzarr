version: 1.0
tags:
    - workflow
    - refactoring
    - quality
content: |-
    # Elegant Redo: Informed Reimplementation

    Discard the current implementation and start fresh, using everything learned during the first attempt to produce an elegant solution.

    ## Philosophy

    The first implementation teaches you the problem. The second implementation solves it well. The knowledge gained from wrestling with edge cases, discovering hidden requirements, and hitting dead ends is the most valuable output of a first attempt - not the code itself.

    ## Process

    1. **Inventory what you know now** - Before deleting anything, document:
       - Hidden requirements discovered during implementation
       - Edge cases that surprised you
       - Architectural constraints revealed by the problem
       - Dependencies and interfaces that must be preserved
       - What worked well and should be kept conceptually
       - What was over-engineered or unnecessarily complex

    2. **Identify the elegant core** - With full knowledge of the problem:
       - What is the simplest abstraction that covers all known cases?
       - What data structures naturally fit the problem?
       - Where did the first attempt fight the language/framework instead of working with it?
       - What can be deleted entirely vs what is essential?

    3. **Scrap and rebuild** - Start clean:
       - Do not copy-paste from the old implementation
       - Write fresh code informed by lessons learned
       - Let the structure emerge from the problem, not from the previous solution
       - Apply reductive principles - less code, fewer abstractions, simpler interfaces

    4. **Validate** - Ensure the new solution:
       - Handles all edge cases discovered in the first attempt
       - Passes existing tests (or improved versions of them)
       - Is demonstrably simpler (fewer lines, fewer abstractions, clearer flow)

    ## When This Applies

    - The current implementation works but feels forced or over-complicated
    - You've discovered the real shape of the problem and the code doesn't match it
    - Accumulated patches have obscured the original design intent
    - The developer explicitly requests a fresh take with accumulated knowledge

    ## Rules

    - Do not preserve code out of sunk cost - judge everything on current merit
    - Simpler is better, but not at the cost of correctness
    - The goal is elegance: the minimum structure that handles the full problem naturally
    - Keep tests - they encode requirements. Rewrite implementation, not specifications.
content_hash: sha256:ddae197e748556b09de9d2095ee350dfd221439f217561f36c17b5d2d35edda6
distilled: |-
    # Elegant Redo: Informed Reimplementation

    Discard current impl and rebuild using lessons from first attempt.

    ## Philosophy
    First impl teaches the problem. Second solves it well. Knowledge from edge cases, hidden requirements, and dead ends is the valuable output—not the code.

    ## Process
    1. **Inventory knowledge** - Before deleting, document:
       - Hidden requirements, surprising edge cases
       - Architectural constraints revealed
       - Dependencies/interfaces to preserve
       - What worked vs what was over-engineered

    2. **Identify elegant core** - With full problem knowledge:
       - Simplest abstraction covering all cases?
       - Natural data structures?
       - Where did first attempt fight the language/framework?
       - What's deletable vs essential?

    3. **Scrap and rebuild** - Start clean:
       - No copy-paste from old impl
       - Let structure emerge from problem
       - Less code, fewer abstractions, simpler interfaces

    4. **Validate** - New solution must:
       - Handle all discovered edge cases
       - Pass existing/improved tests
       - Be demonstrably simpler

    ## When to Apply
    - Impl works but feels forced/overcomplicated
    - Real problem shape doesn't match code
    - Accumulated patches obscure design intent
    - Developer explicitly requests fresh take

    ## Rules
    - No sunk cost preservation—judge on current merit
    - Simpler is better, but not at correctness cost
    - Goal: minimum structure handling full problem naturally
    - Keep tests (requirements); rewrite implementation
distilled_by: claude-code
