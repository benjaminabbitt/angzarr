# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ DO NOT EDIT - Changes will be overwritten on next 'scm copy'              │
# │ To customize: scm fragment edit {{name}} then re-run 'scm copy'          │
# └─────────────────────────────────────────────────────────────────────────────┘
version: 1.0
tags:
    - code
    - quality
    - refactoring
content: |-
    # Reductive Development

    **Disclaimer:** This approach is intended for greenfield/prototype projects where aggressive cleanup is acceptable. For production systems with external consumers, use judgment about backwards compatibility.

    Before starting any significant task, reduce the codebase first.

    ## Pre-Task Reduction

    When given a new feature request, bug fix, or significant change:

    1. **Pause before implementing** - Do not start the task immediately
    2. **Scan for duplication** - Search the codebase for:
       - Duplicate functions or methods doing the same thing
       - Similar code patterns that could be consolidated
       - Copy-pasted logic that should be extracted
       - Multiple implementations of the same concept
    3. **Identify reduction opportunities** - Look for:
       - Dead code that can be deleted
       - Unused imports, variables, parameters
       - Over-engineered abstractions that add no value
       - Wrapper functions that just delegate
       - Compatibility shims for removed features
    4. **Reduce first** - Clean up what you find before starting the actual task
    5. **Then proceed** - Start the requested work on a smaller, cleaner codebase

    ## Reduction Rules

    - **Preserve coverage**: Do not reduce code in ways that meaningfully reduce test coverage
    - **Keep tests passing**: All reductions must leave the test suite green
    - **Small is better**: A smaller codebase is easier to understand, modify, and maintain
    - **Delete over deprecate**: Remove unused code entirely rather than marking it deprecated

    ## Why Reduce First

    - Smaller codebases have fewer bugs
    - Less code means less to understand before making changes
    - Duplication removed now won't be duplicated further by your changes
    - You may find that the task becomes simpler after reduction
    - Technical debt compounds - pay it down before adding more code

    ## What Counts as Significant

    Apply this process for:
    - New features
    - Bug fixes requiring more than a few lines
    - Refactoring tasks
    - Any change touching multiple files

    Skip for:
    - Typo fixes
    - Comment updates
    - Single-line changes
    - Documentation-only changes
content_hash: sha256:1b9ed3cca66ec1056a39ea77a98b011cc95e22e39c97a69d7c6277b0aa52d175
distilled: |-
    # Reductive Development

    **Disclaimer:** For greenfield/prototype projects only. Use judgment on backwards compatibility for production systems.

    Reduce codebase before starting significant tasks.

    ## Pre-Task Process

    1. **Pause** - Don't implement immediately
    2. **Scan for duplication** - duplicate functions, similar patterns, copy-pasted logic, multiple implementations
    3. **Identify reduction targets** - dead code, unused imports/variables/params, over-engineered abstractions, wrapper functions, compatibility shims
    4. **Reduce first** - clean up before starting task
    5. **Proceed** - work on smaller codebase

    ## Rules

    - Preserve test coverage
    - Keep tests green
    - Smaller = better
    - Delete over deprecate

    ## Why

    - Fewer bugs in smaller codebases
    - Less to understand before changes
    - Prevents duplication spread
    - Task may simplify post-reduction
    - Tech debt compounds

    ## Apply To

    New features, multi-line bug fixes, refactoring, multi-file changes

    ## Skip For

    Typos, comments, single-line changes, docs-only
distilled_by: claude-code
