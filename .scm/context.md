<!-- DO NOT EDIT: This file is auto-generated by `scm run`. Edit source fragments instead. -->

# Architect Review

Review code for structure & maintainability.

## Separation of Concerns
- Clear responsibility division?
- Business logic separate from infra?
- Cross-cutting concerns isolated?

## Testability
- Components testable in isolation?
- Dependencies injectable/mockable?

## Module Boundaries
- Well-defined interfaces?
- Minimal coupling, correct dependency direction?

## Technical Debt
- Unnecessary complexity?
- Shortcuts documented (TODOs)?
- Solution proportional to problem?

## Cohesion
- Single purpose per module?
- Related functions grouped?
- Functionality in right place?

## Extensibility
- Extendable without modification?
- Extension points identified?
- Open for future needs, no overengineering?

## Consistency
- Follows existing patterns?
- Similar problems solved similarly?
- Fits overall system design?

---

# Concurrency Review

## Race Conditions
- Shared resources protected?
- Concurrent access → data corruption?
- Check-then-act atomic?

## Thread Safety
- Data structures thread-safe/synchronized?
- Mutable state shared?
- Thread-local alternatives?

## Synchronization
- Lock granularity appropriate?
- Locks held minimally?
- Lock ordering consistent (deadlock prevention)?

## Deadlock Prevention
- Circular wait possible?
- Nested locks ordered consistently?
- Timeouts used?

## Atomic Operations
- Compound ops atomic when needed?
- Atomic primitives correct?
- Memory ordering considered?

## Resource Management
- Resources released in concurrent contexts?
- Resource exhaustion under load?
- Connection pools sized properly?

---

# Domain Expert Review

Review code w/ deep business domain familiarity.

## First: Build Domain Understanding

Read before reviewing:
- `resources/` or `docs/` documentation
- `*.feature` files (Cucumber/Gherkin) - expected behavior
- READMEs for context
- Domain glossary/ubiquitous language definitions

## Core Questions
- Domain logic correctly implemented?
- Business rules properly enforced?
- Domain model accurate/complete?

## Semantic Accuracy
- Domain terms used correctly/consistently?
- Code matches ubiquitous language?
- Concepts named as domain experts recognize?

## Business Rules
- All constraints enforced?
- Invariants maintained?
- State transitions valid per domain rules?

## Edge Cases
- Business logic edge cases handled?
- Boundary conditions addressed?
- Exceptional scenarios covered?

## Domain Integrity
- Aggregates properly bounded?
- Domain events raised appropriately?
- Domain logic leaking into infrastructure?

---

# Performance Review

## Complexity
- Time/space Big-O?
- Hidden O(n) in loops?
- Better algorithm available?

## Data Structures
- Right structure for access pattern?
- HashMap vs TreeMap (ordering needed?)
- Array vs linked list (random vs sequential?)
- Set vs list (duplicates?)
- Heap/priority queue fit?

## Memory
- Minimize allocations in hot paths
- Avoid unnecessary copies
- Stream vs load all
- Pass large objects by ref

## Caching
- Cache expensive repeated computations
- Correct invalidation?
- Bounded cache sizes

## I/O & Network
- Batch I/O ops
- Paginate large datasets
- Minimize round-trips
- Use async where appropriate

## Loops
- Hoist invariants
- Early termination
- Parallelizable?

## Profiling
- Actually profiled?
- Real bottlenecks identified?
- Micro-opts justified by measurement?
- Avoid premature optimization

---

# Standards & Readability Review

Code review focus: canonical patterns, textbook approaches, long-term readability.

## Naming
- Intent-revealing names
- Avoid abbreviations (unless universal)
- Function names describe *what*, not *how*
- Booleans as questions: isValid, hasItems

## Organization
- Follow language/framework standards
- Files by feature or layer
- Group related code
- Minimal, organized imports

## Functions
- Single responsibility
- Small, understandable at glance
- Minimize/document side effects
- Clear signatures

## Documentation
- Public APIs: purpose, params, returns
- Explain non-obvious algorithms
- "Why" comments where needed
- Keep docs synced with code

## Patterns
- Use standard design patterns appropriately
- Prefer stdlib over reinventing
- Follow language idioms
- Avoid anti-patterns

## Errors
- Handle explicitly, never swallow silently
- Descriptive, actionable messages
- Clear happy path vs error paths
- Don't use exceptions for control flow

## Readability
- Newcomer-understandable
- Clarity over cleverness
- Break complex expressions into named values
- Code reads like prose

## Consistency
- Consistent style throughout
- Similar problems → similar solutions
- Follow team/language conventions

---

# Communication Style

## Do
- State limitations immediately ("Cannot verify X without Y", "Approach has limitation Z", "Need clarification on A")
- Ask for help when: requirements ambiguous, multiple valid approaches, trade-offs need business input, uncertain about context
- Lead with key info first, details second, rationale last
- Cite sources: API docs, best practices, performance claims, security recs
- TDD mandatory - verify tests pass before marking complete

## Don't
- No sycophancy (no praise, enthusiasm markers, validation seeking)
- No flattery/excessive politeness - be direct
- No assumptions - ask if unsure, state when guessing

---

# Security

## Core Principles
- No secrets in commits (use env vars)
- Validate external input
- Parameterized DB queries
- Update dependencies
- Least privilege

## Review Checklist
- Input validation
- Path traversal
- Injection (SQL/cmd/XSS)
- TOCTOU issues
- Privilege escalation
- Auth/authz correct
- Secrets managed
- Crypto correct
- Data exposure
- Dependency vulns

---

# Code Quality

## Before Writing
- Research codebase first; read existing patterns
- No duplication—reuse/extend existing code

## Size
- Files <500 LOC; exceed only w/ high coupling+cohesion
- Small, single-purpose functions
- Optimize for readability
- Separate interfaces from implementations

## Naming
- Interfaces = the thing (UserService is Protocol, no IWhatever)
- Implementations = Default or descriptive how

## Philosophy
- SOLID, KISS, YAGNI

## Principles
- Follow lang style guides; use type hints
- Self-documenting code > comments
- Document public APIs
- Composition > inheritance

## Coupling/Cohesion
- Low coupling, high cohesion
- Single well-defined purpose per module

## Markers
- TODO, FIXME, NOTE, HACK

## Performance
- Profile first; document requirements in tests
- Appropriate data structures; state complexity
- Consider memory patterns

## Cleanup
- Kill unused processes
- Remove dead code/imports/variables

## Comments
- No change-tracking—git handles history
- No commented-out code
- Explain *why*, not *what*

---

# 12-Factor App

Methodology for cloud-native SaaS: portable, scalable, maintainable.

## I. Codebase
1 repo, many deploys. Shared code → libraries via deps. Same codebase across dev/staging/prod.

## II. Dependencies
Declare explicitly (go.mod, package.json, requirements.txt). Isolate deps—no system-wide packages.

## III. Config
Store in env vars. Strict separation from code. Never commit secrets.

## IV. Backing Services
Treat as attached resources (DBs, queues, caches, APIs). Swap local↔cloud via config only.

## V. Build, Release, Run
- **Build**: code → executable (compile, fetch deps)
- **Release**: build + config, unique ID, immutable
- **Run**: execute in environment

Rollback = deploy previous release.

## VI. Processes
Stateless, share-nothing. Persist data in backing services. No sticky sessions—use Redis/Memcached for session state.

## VII. Port Binding
Self-contained; export HTTP via port binding. Routing layer maps hostname → port.

## VIII. Concurrency
Scale horizontally via process model. Web processes for HTTP, workers for background jobs. Use OS process manager.

## IX. Disposability
Fast startup, graceful shutdown on SIGTERM. Return incomplete jobs to queue. Design for sudden death.

## X. Dev/Prod Parity
Minimize time/personnel/tools gaps. Same backing services across environments. Use Docker for local parity.

## XI. Logs
Event streams to stdout. Env routes to aggregators (Splunk, Datadog, ELK). App decoupled from log management.

## XII. Admin Processes
Run one-off tasks (migrations, REPL, scripts) in identical environment. Admin code ships with app code.

---

# Documentation

## README
- Read first before acting
- Update when adding commands/features
- Keep current with project state

## Ask Before Creating
- *.md files (REFACTORING.md, arch docs)
- Planning/strategy docs
- Project tracking files
- Meta-docs

**Exception:** README updates for new features OK

## Plan Files
- Place in `.plan/` directory
- Add `.plan/` to `.gitignore` (never commit)
- Use descriptive names: `.plan/feature-name.md`

## Don't
- Add progress comments in code ("reorganized...", "refactored X to Y")
- Include changelog-style comments
- Add "Updated on...", "Changed from...", revision history in files
- History belongs in VCS, not data

## Do
- Suggest doc needs first
- Summarize in chat
- Update existing docs
- Create code/tests/config
- Use commit messages for tracking

---

# Workarounds & Problem Solving

**Core:** Find root cause before solving. Fix at source.

## When Functionality Fails

1. **Root cause first** - No workarounds without asking
2. **Simple problem needing complex fix?** - Stop, ask questions
3. **Prompt with options:**
   - Fix properly (effort estimate)
   - Workaround (document trade-offs)
   - Disable test temporarily (document why)
   - Alternatives
4. **Cost/benefit:** pros/cons, tech debt, maintainability, time
5. **Document** reasoning for chosen path

## Questions to Ask
- Fix properly vs workaround?
- Pros/cons of each?
- Tech debt impact?
- Disable test temporarily?
- Alternative approaches?

---

# Pushback Guidelines

## When to Push Back
If asked to: skip tests, add untested features, ignore type hints, work around (vs fix) lint errors

## Response Pattern
1. State why problematic
2. Explain consequences
3. Suggest correct approach
4. Defer if insisted, note tech debt

## Feature Start Questions
- Acceptance criteria?
- Performance requirements?
- Error cases to handle?
- Security implications?
- What to log?
- Dependencies?
- Testing approach?
- Error messages needed?

## Component Design Questions
- Required dependencies?
- Interface/protocol for dependencies?
- Logging context?
- Error conditions & messages?