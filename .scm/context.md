<!-- DO NOT EDIT: This file is auto-generated by `scm run`. Edit source fragments instead. -->

# Rust Dev

## Tooling
- Version: Cargo.toml
- Tests: `#[cfg(test)]`, cucumber-rs (Gherkin)
- Quality: clippy, rustfmt, cargo-audit
- Logging: tracing

## Test Layout
- Unit: inline `#[cfg(test)]`
- Integration: `tests/*.rs`
- Acceptance: `tests/acceptance/features/*.feature`

## Logging
```rust
// logmsg.rs
pub const USER_CREATED: &str = "user_created";
info!(message = logmsg::USER_CREATED, username = %username);
```

## Error Constants
```rust
pub mod errmsg {
    pub const DIVIDE_BY_ZERO: &str = "cannot divide by zero";
}
#[error("{}", errmsg::DIVIDE_BY_ZERO)]
DivideByZero,
```

## IoC
```rust
impl<R: UserRepository, E: EmailService> UserService<R, E> { ... }
pub type DefaultUserService = UserService<SqlUserRepository, SmtpEmailService>;
```

## Best Practices
- Memory: `Arc<RwLock<T>>` read-heavy, `Arc<Mutex<T>>` write-heavy, accept `&str`
- Concurrency: thread-safe, minimal lock time, consistent order, document
- Errors: `Result<T, E>` + `?`, NO `unwrap()`/`expect()` in libs
- Style: `cargo fmt`, fix clippy, `///` docs explain WHY

---

# Communication Style

## Do
- State limitations immediately ("Cannot verify X without Y", "Approach has limitation Z", "Need clarification on A")
- Ask for help when: requirements ambiguous, multiple valid approaches, trade-offs need business input, uncertain about context
- Lead with key info first, details second, rationale last
- Cite sources: API docs, best practices, performance claims, security recs
- TDD mandatory - verify tests pass before marking complete

## Don't
- No sycophancy (no praise, enthusiasm markers, validation seeking)
- No flattery/excessive politeness - be direct
- No assumptions - ask if unsure, state when guessing

---

# Security

## Core Principles
- No secrets in commits (use env vars)
- Validate external input
- Parameterized DB queries
- Update dependencies
- Least privilege

## Review Checklist
- Input validation
- Path traversal
- Injection (SQL/cmd/XSS)
- TOCTOU issues
- Privilege escalation
- Auth/authz correct
- Secrets managed
- Crypto correct
- Data exposure
- Dependency vulns

---

# Code Quality

## Before Writing
- Research codebase first; read existing patterns
- No duplication—reuse/extend existing code

## Size
- Files <500 LOC; exceed only w/ high coupling+cohesion
- Small, single-purpose functions
- Optimize for readability
- Separate interfaces from implementations

## Naming
- Interfaces = the thing (UserService is Protocol, no IWhatever)
- Implementations = Default or descriptive how

## Philosophy
- SOLID, KISS, YAGNI

## Principles
- Follow lang style guides; use type hints
- Self-documenting code > comments
- Document public APIs
- Composition > inheritance

## Coupling/Cohesion
- Low coupling, high cohesion
- Single well-defined purpose per module

## Markers
- TODO, FIXME, NOTE, HACK

## Performance
- Profile first; document requirements in tests
- Appropriate data structures; state complexity
- Consider memory patterns

## Cleanup
- Kill unused processes
- Remove dead code/imports/variables

## Comments
- No change-tracking—git handles history
- No commented-out code
- Explain *why*, not *what*

---

# 12-Factor App

Methodology for cloud-native SaaS: portable, scalable, maintainable.

## I. Codebase
1 repo, many deploys. Shared code → libraries via deps. Same codebase across dev/staging/prod.

## II. Dependencies
Declare explicitly (go.mod, package.json, requirements.txt). Isolate deps—no system-wide packages.

## III. Config
Store in env vars. Strict separation from code. Never commit secrets.

## IV. Backing Services
Treat as attached resources (DBs, queues, caches, APIs). Swap local↔cloud via config only.

## V. Build, Release, Run
- **Build**: code → executable (compile, fetch deps)
- **Release**: build + config, unique ID, immutable
- **Run**: execute in environment

Rollback = deploy previous release.

## VI. Processes
Stateless, share-nothing. Persist data in backing services. No sticky sessions—use Redis/Memcached for session state.

## VII. Port Binding
Self-contained; export HTTP via port binding. Routing layer maps hostname → port.

## VIII. Concurrency
Scale horizontally via process model. Web processes for HTTP, workers for background jobs. Use OS process manager.

## IX. Disposability
Fast startup, graceful shutdown on SIGTERM. Return incomplete jobs to queue. Design for sudden death.

## X. Dev/Prod Parity
Minimize time/personnel/tools gaps. Same backing services across environments. Use Docker for local parity.

## XI. Logs
Event streams to stdout. Env routes to aggregators (Splunk, Datadog, ELK). App decoupled from log management.

## XII. Admin Processes
Run one-off tasks (migrations, REPL, scripts) in identical environment. Admin code ships with app code.

---

# Documentation

## README
- Read first before acting
- Update when adding commands/features
- Keep current with project state

## Ask Before Creating
- *.md files (REFACTORING.md, arch docs)
- Planning/strategy docs
- Project tracking files
- Meta-docs

**Exception:** README updates for new features OK

## Plan Files
- Place in `.plan/` directory
- Add `.plan/` to `.gitignore` (never commit)
- Use descriptive names: `.plan/feature-name.md`

## Don't
- Add progress comments in code ("reorganized...", "refactored X to Y")
- Include changelog-style comments
- Add "Updated on...", "Changed from...", revision history in files
- History belongs in VCS, not data

## Do
- Suggest doc needs first
- Summarize in chat
- Update existing docs
- Create code/tests/config
- Use commit messages for tracking

---

# Workarounds & Problem Solving

**Core:** Find root cause before solving. Fix at source.

## When Functionality Fails

1. **Root cause first** - No workarounds without asking
2. **Simple problem needing complex fix?** - Stop, ask questions
3. **Prompt with options:**
   - Fix properly (effort estimate)
   - Workaround (document trade-offs)
   - Disable test temporarily (document why)
   - Alternatives
4. **Cost/benefit:** pros/cons, tech debt, maintainability, time
5. **Document** reasoning for chosen path

## Questions to Ask
- Fix properly vs workaround?
- Pros/cons of each?
- Tech debt impact?
- Disable test temporarily?
- Alternative approaches?

---

# Pushback Guidelines

## When to Push Back
If asked to: skip tests, add untested features, ignore type hints, work around (vs fix) lint errors

## Response Pattern
1. State why problematic
2. Explain consequences
3. Suggest correct approach
4. Defer if insisted, note tech debt

## Feature Start Questions
- Acceptance criteria?
- Performance requirements?
- Error cases to handle?
- Security implications?
- What to log?
- Dependencies?
- Testing approach?
- Error messages needed?

## Component Design Questions
- Required dependencies?
- Interface/protocol for dependencies?
- Logging context?
- Error conditions & messages?

---

# Elegant Redo: Informed Reimplementation

Discard current impl and rebuild using lessons from first attempt.

## Philosophy
First impl teaches the problem. Second solves it well. Knowledge from edge cases, hidden requirements, and dead ends is the valuable output—not the code.

## Process
1. **Inventory knowledge** - Before deleting, document:
   - Hidden requirements, surprising edge cases
   - Architectural constraints revealed
   - Dependencies/interfaces to preserve
   - What worked vs what was over-engineered

2. **Identify elegant core** - With full problem knowledge:
   - Simplest abstraction covering all cases?
   - Natural data structures?
   - Where did first attempt fight the language/framework?
   - What's deletable vs essential?

3. **Scrap and rebuild** - Start clean:
   - No copy-paste from old impl
   - Let structure emerge from problem
   - Less code, fewer abstractions, simpler interfaces

4. **Validate** - New solution must:
   - Handle all discovered edge cases
   - Pass existing/improved tests
   - Be demonstrably simpler

## When to Apply
- Impl works but feels forced/overcomplicated
- Real problem shape doesn't match code
- Accumulated patches obscure design intent
- Developer explicitly requests fresh take

## Rules
- No sunk cost preservation—judge on current merit
- Simpler is better, but not at correctness cost
- Goal: minimum structure handling full problem naturally
- Keep tests (requirements); rewrite implementation

---

# Prove It: Behavioural Diff Demonstration

Show concrete behaviour difference between main branch and current branch.

## Process
1. Identify behavioural claims - what should differ?
2. Design demonstrations exercising changed behaviour
3. Show before (main branch behaviour)
4. Show after (current branch behaviour)
5. Present side-by-side diff of inputs, outputs, effects

## Demonstration Methods
- Test output comparison across branches
- CLI invocation: same command, different output
- Code walkthrough: trace input through both paths, show divergence
- API calls: same request, different responses
- Error scenarios: differing failure modes

## Format

Per behavioural change:
```
## [Behaviour description]
### Main branch
Input: ... Output/Behaviour: ...
### This branch
Input: ... Output/Behaviour: ...
### What changed
[Concise diff explanation + why it matters]
```

## Rules
- Cover all intended changes, not just happy path
- Include edge cases and error conditions
- For pure refactors, demonstrate preserved behaviour
- Show evidence, don't just claim
- If local demo impossible, describe what would be tested and how

---

# Grill Me: Change Comprehension Gate

Quiz developer on their changes before PR creation to verify understanding.

## Process
1. Analyze diff (staged + unstaged)
2. Identify key decisions, trade-offs, edge cases, non-obvious implications
3. Ask pointed questions one at a time testing genuine understanding
4. Evaluate answers for real comprehension
5. Gate PR on sufficient understanding

## Question Categories
- **Intent**: What problem solved? Why this approach?
- **Impact**: What else affected? What breaks if this fails?
- **Edge cases**: Null/empty/concurrent behavior?
- **Trade-offs**: What sacrificed? Technical debt introduced?
- **Rollback**: How to revert safely? Blast radius?

## Grading
- **Pass**: Explains intent, impact, trade-offs clearly → proceed with PR
- **Partial**: Gaps exist → point out gaps, re-quiz weak areas
- **Fail**: Can't explain core decisions → no PR, suggest review areas

## Rules
- Rigorous but fair; test understanding, not memorization
- Scale difficulty to change complexity
- Explain wrong answers before continuing
- Never create PR until developer passes

---

# Git Practices

## Branching
- Create short descriptive branch before changes
- Keep related changes in single branch

## General
- Use `git log` for context/history
- Use `git rm` not `rm` for file removal

## Commits
- Keep messages brief, describe only code changes
- **NEVER mention Claude, Anthropic, AI, or "Generated with"**

## Breaking Changes
- Pre-1.0/new major: no backwards compat needed, clean up deprecated code
- Post-1.0 minor/patch: discuss first

## Hooks (lefthook)
- Config: `lefthook.yml`
- Pre-commit: lint, format, test (parallel)

## Pre-commit
- Run linters/formatters/tests
- Fix all issues before commit
- Auto-fix pre-commit errors without asking

## Bypass
- Only for WIP on feature branches
- Document with `--no-verify` + reason

---

# ast-grep: Structural Code Search/Replace

AST-aware find/replace for large-scale refactoring. Matches code structure, not text.

## When to Use
- Renaming functions/variables/types across codebase
- Refactoring API patterns, migrating deprecated code
- Finding structural patterns (multi-file changes)

## Why Over Text Tools
- Structure/language-aware, safe refactoring
- Won't match strings/comments, preserves formatting

## Usage

```bash
# Search
ast-grep --pattern 'console.log($ARG)' --lang ts

# Replace
ast-grep --pattern 'console.log($ARG)' --rewrite 'logger.debug($ARG)' --lang ts

# Interactive review
ast-grep -p 'OLD' -r 'NEW' --interactive

# Apply in place
ast-grep -p 'OLD' -r 'NEW' --lang py --update-all
```

## Pattern Syntax
- `$NAME` — matches single AST node
- `$$$` — matches zero+ nodes (variadic)
- `$_` — wildcard (no capture)
- Literal code matches exactly

## Examples

```bash
ast-grep -p 'getUserById($ID)' -r 'fetchUser($ID)' --lang ts
ast-grep -p 'from "old/path"' -r 'from "new/path"' --lang ts
ast-grep -p 'createUser($NAME, $EMAIL, true)' -r 'createUser($NAME, $EMAIL)' --lang ts
```

## Rule Files

```yaml
id: no-console-log
language: typescript
rule:
  pattern: console.log($$$ARGS)
fix: "logger.debug($$$ARGS)"
```

```bash
ast-grep scan --rule rules/no-console-log.yaml
```

## Workflow
1. Test pattern (preview matches)
2. Review interactively
3. Apply with `--update-all`
4. Run tests, commit

## Install

```bash
brew install ast-grep
cargo install ast-grep --locked
npm install -g @ast-grep/cli
```

---

# just: Command Runner

- Define common tasks in justfile (e.g., `just test`, `just lint`, `just run`)
- Language-agnostic task runner
- Use `git rev-parse --show-toplevel` for repo root (TOP)
- Base paths on TOP
- Create target for commands used 3+ times
- Document purpose, caveats, requirements, prerequisites

## Cross-Platform

- Platform files: `justfile.nix`, `justfile.windows`
- Use platform_justfile pattern for imports
- Sync changes across platform files when simple
- Minimize platform differences

---

# Prototype Mode

Build correctly. No compromise.

## No Backwards Compatibility

- Delete deprecated code immediately
- Remove old APIs entirely
- Break dependencies requiring compromise
- Rip out legacy patterns on sight
- Wrong? Delete and rebuild correctly

## No Legacy Accommodation

- Bad format → new format, don't support both
- Wrong API → new API, don't wrap old
- Broken behavior → fix code, don't preserve bug
- Migration = someone else's problem

## Hard Changes Only

When existing code resists:
1. Delete offending code
2. Rebuild correctly
3. Fix everything that breaks
4. Never add shims/flags/fallbacks

"This breaks X" → fix X

## In Practice

- Rename correctly, fix all refs
- Correct signatures, fix all callers
- Restructure data, fix all consumers
- Remove bad params, fix call sites
- Correct return types, fix handlers

## Forbidden Patterns

Never use:
- `// Deprecated` comments — delete now
- `@deprecated` annotations — delete code
- Feature flags for old behavior
- Version checks/legacy conditionals
- Old→new wrapper functions
- Defaults preserving old behavior
- Union types for old+new formats
- Any "backwards compatibility" comments
- Fallback logic for renames
- Multi-version case handling
- "Handle both formats" logic when you control data generation

## Standard

One version: correct one.

No v1 compat. No migration period. No deprecation cycle. Only correct implementation, built correctly, now.

Writing code for "the old way"? Stop. Delete it. Only the new way exists.

---

# Reductive Development

**Disclaimer:** For greenfield/prototype projects only. Use judgment on backwards compatibility for production systems.

Reduce codebase before starting significant tasks.

## Pre-Task Process

1. **Pause** - Don't implement immediately
2. **Scan for duplication** - duplicate functions, similar patterns, copy-pasted logic, multiple implementations
3. **Identify reduction targets** - dead code, unused imports/variables/params, over-engineered abstractions, wrapper functions, compatibility shims
4. **Reduce first** - clean up before starting task
5. **Proceed** - work on smaller codebase

## Rules

- Preserve test coverage
- Keep tests green
- Smaller = better
- Delete over deprecate

## Why

- Fewer bugs in smaller codebases
- Less to understand before changes
- Prevents duplication spread
- Task may simplify post-reduction
- Tech debt compounds

## Apply To

New features, multi-line bug fixes, refactoring, multi-file changes

## Skip For

Typos, comments, single-line changes, docs-only

---

# TDD Workflow

## Cycle (Mandatory)
1. **Red**: Write failing test first; verify fails correctly; ensure isolation
2. **Green**: Minimal code to pass; no extras
3. **Refactor**: Keep green; apply SOLID; remove duplication; use existing libs; improve names

## Integration Tests
- Run actual binaries (no hooks)
- Tag slow tests appropriately
- Clean up after tests

## Naming
`test_<action>_<condition>_<expected_result>`
- Python: snake_case
- C#/Java/JS: camelCase
- Readability > format

## Organization
- Prioritize readability
- Order by complexity: simple examples top, edge cases bottom
- Tests = documentation