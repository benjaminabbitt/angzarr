---
sidebar_position: 4
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Projectors

A **projector** subscribes to events and performs side effects—typically building read models, writing to databases, or streaming to external systems. Projectors transform the event stream into query-optimized views.

Unlike aggregates and sagas, projectors are **read-only** from the event sourcing perspective. They observe events but never emit commands back to aggregates.

---

## Common Use Cases

| Projector | Events | Output |
|-----------|--------|--------|
| Search indexer | Product events | Elasticsearch updates |
| Dashboard stream | All domain events | WebSocket push |
| Analytics ETL | Transaction events | Data warehouse |
| Cache warmer | Player events | Redis cache |
| Output renderer | Poker events | Console text |

---

## Example: Output Projector

Transforms poker events into human-readable text:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python
from angzarr_client import Projector

class OutputProjector(Projector):
    def __init__(self):
        self.player_names: dict[str, str] = {}

    def handle_player_registered(self, event: PlayerRegistered):
        self.player_names[event.player_id] = event.username
        print(f"[Player] {event.username} registered")

    def handle_funds_deposited(self, event: FundsDeposited):
        name = self.player_names.get(event.player_id, event.player_id)
        print(f"[Player] {name} deposited ${event.amount / 100:.2f}")

    def handle_cards_dealt(self, event: CardsDealt):
        for player in event.players:
            name = self.player_names.get(player.player_id, player.player_id)
            cards = format_cards(player.hole_cards)
            print(f"[Hand] {name} dealt {cards}")
```

</TabItem>
<TabItem value="go" label="Go">

```go
type OutputProjector struct {
    playerNames map[string]string
}

func (p *OutputProjector) HandlePlayerRegistered(event *PlayerRegistered) {
    p.playerNames[event.PlayerId] = event.Username
    fmt.Printf("[Player] %s registered\n", event.Username)
}

func (p *OutputProjector) HandleFundsDeposited(event *FundsDeposited) {
    name := p.playerNames[event.PlayerId]
    if name == "" {
        name = event.PlayerId
    }
    fmt.Printf("[Player] %s deposited $%.2f\n", name, float64(event.Amount)/100)
}

func (p *OutputProjector) HandleCardsDealt(event *CardsDealt) {
    for _, player := range event.Players {
        name := p.playerNames[player.PlayerId]
        cards := formatCards(player.HoleCards)
        fmt.Printf("[Hand] %s dealt %s\n", name, cards)
    }
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
pub struct OutputProjector {
    player_names: HashMap<String, String>,
}

impl OutputProjector {
    pub fn handle_player_registered(&mut self, event: &PlayerRegistered) {
        self.player_names.insert(event.player_id.clone(), event.username.clone());
        println!("[Player] {} registered", event.username);
    }

    pub fn handle_funds_deposited(&mut self, event: &FundsDeposited) {
        let name = self.player_names.get(&event.player_id)
            .map(|s| s.as_str())
            .unwrap_or(&event.player_id);
        println!("[Player] {} deposited ${:.2}", name, event.amount as f64 / 100.0);
    }

    pub fn handle_cards_dealt(&mut self, event: &CardsDealt) {
        for player in &event.players {
            let name = self.player_names.get(&player.player_id)
                .map(|s| s.as_str())
                .unwrap_or(&player.player_id);
            let cards = format_cards(&player.hole_cards);
            println!("[Hand] {} dealt {}", name, cards);
        }
    }
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
public class OutputProjector {
    private final Map<String, String> playerNames = new HashMap<>();

    @Projects(PlayerRegistered.class)
    public void handlePlayerRegistered(PlayerRegistered event) {
        playerNames.put(event.getPlayerId(), event.getUsername());
        System.out.printf("[Player] %s registered%n", event.getUsername());
    }

    @Projects(FundsDeposited.class)
    public void handleFundsDeposited(FundsDeposited event) {
        String name = playerNames.getOrDefault(event.getPlayerId(), event.getPlayerId());
        System.out.printf("[Player] %s deposited $%.2f%n", name, event.getAmount() / 100.0);
    }

    @Projects(CardsDealt.class)
    public void handleCardsDealt(CardsDealt event) {
        for (PlayerCards player : event.getPlayersList()) {
            String name = playerNames.getOrDefault(player.getPlayerId(), player.getPlayerId());
            String cards = formatCards(player.getHoleCardsList());
            System.out.printf("[Hand] %s dealt %s%n", name, cards);
        }
    }
}
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp
public class OutputProjector
{
    private readonly Dictionary<string, string> _playerNames = new();

    [Projects(typeof(PlayerRegistered))]
    public void HandlePlayerRegistered(PlayerRegistered @event)
    {
        _playerNames[@event.PlayerId] = @event.Username;
        Console.WriteLine($"[Player] {@event.Username} registered");
    }

    [Projects(typeof(FundsDeposited))]
    public void HandleFundsDeposited(FundsDeposited @event)
    {
        var name = _playerNames.GetValueOrDefault(@event.PlayerId, @event.PlayerId);
        Console.WriteLine($"[Player] {name} deposited ${@event.Amount / 100.0:F2}");
    }

    [Projects(typeof(CardsDealt))]
    public void HandleCardsDealt(CardsDealt @event)
    {
        foreach (var player in @event.Players)
        {
            var name = _playerNames.GetValueOrDefault(player.PlayerId, player.PlayerId);
            var cards = FormatCards(player.HoleCards);
            Console.WriteLine($"[Hand] {name} dealt {cards}");
        }
    }
}
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp
class OutputProjector {
public:
    void handle_player_registered(const PlayerRegistered& event) {
        player_names_[event.player_id()] = event.username();
        std::cout << "[Player] " << event.username() << " registered\n";
    }

    void handle_funds_deposited(const FundsDeposited& event) {
        auto it = player_names_.find(event.player_id());
        std::string name = (it != player_names_.end()) ? it->second : event.player_id();
        std::cout << "[Player] " << name << " deposited $"
                  << std::fixed << std::setprecision(2)
                  << (event.amount() / 100.0) << "\n";
    }

    void handle_cards_dealt(const CardsDealt& event) {
        for (const auto& player : event.players()) {
            auto it = player_names_.find(player.player_id());
            std::string name = (it != player_names_.end()) ? it->second : player.player_id();
            std::string cards = format_cards(player.hole_cards());
            std::cout << "[Hand] " << name << " dealt " << cards << "\n";
        }
    }

private:
    std::unordered_map<std::string, std::string> player_names_;
};
```

</TabItem>
</Tabs>

---

## StateRouter

Use the `StateRouter` to register event handlers:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python
from angzarr_client import StateRouter

router = StateRouter("prj-output")
    .subscribes("player", ["PlayerRegistered", "FundsDeposited"])
    .subscribes("hand", ["CardsDealt", "ActionTaken", "PotAwarded"])
    .on("PlayerRegistered", handle_player_registered)
    .on("FundsDeposited", handle_funds_deposited)
    .on("CardsDealt", handle_cards_dealt)
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
let router = StateRouter::new("prj-output")
    .subscribes("player", &["PlayerRegistered", "FundsDeposited"])
    .subscribes("hand", &["CardsDealt", "ActionTaken", "PotAwarded"])
    .on::<PlayerRegistered>(handle_player_registered)
    .on::<FundsDeposited>(handle_funds_deposited)
    .on::<CardsDealt>(handle_cards_dealt);
```

</TabItem>
</Tabs>

---

## Multi-Domain Projectors

Projectors can subscribe to events from multiple domains:

```python
router = StateRouter("prj-output")
    .subscribes("player", ["PlayerRegistered", "FundsDeposited"])
    .subscribes("table", ["PlayerJoined", "HandStarted"])
    .subscribes("hand", ["CardsDealt", "ActionTaken"])
```

This is safe for projectors because they only observe—unlike sagas which must handle the complexity of multi-domain command generation.

---

## Synchronous vs Asynchronous

| Mode | Use Case | Behavior |
|------|----------|----------|
| **Async** (default) | Analytics, search indexing | Fire-and-forget |
| **Sync** | Read-after-write | Command waits for projector |

Synchronous projections enable CQRS patterns where commands must return updated read models.

---

## Position Tracking

Projectors track their position in the event stream to enable:
- **Catch-up**: Resume from last processed event after restart
- **Replay**: Rebuild read models from scratch

The framework manages position tracking automatically.

---

## Next Steps

- **[Process Managers](/components/process-manager)** — Stateful multi-domain coordination
- **[Testing](/operations/testing)** — Testing projectors with Gherkin
