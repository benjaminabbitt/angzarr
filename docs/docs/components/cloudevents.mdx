---
sidebar_position: 6
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# CloudEvents Projector

The **CloudEvents projector** transforms internal domain events into [CloudEvents 1.0](https://cloudevents.io/) format and publishes them to external systems via HTTP webhooks or Kafka.

This enables event-driven integrations where external consumers (partner APIs, analytics pipelines, notification services) receive filtered, public-facing events without accessing internal event stores.

---

## Architecture

```
                    Client Code                        Framework
                    ───────────                        ─────────
EventBook ──→ [ProjectorHandler] ──→ Projection ──→ [CloudEventsCoordinator] ──→ Sink
              (filters/transforms)    (CloudEventsResponse           (HTTP/Kafka)
                                       packed in .projection)
```

**Client projectors** use existing projector libraries (`ProjectorHandler`, `StateRouter`) to:
1. Receive internal events
2. Filter sensitive fields (create "public" versions)
3. Pack `CloudEventsResponse` into `Projection.projection`

**Framework coordinator** detects `CloudEventsResponse` by type URL and:
1. Converts proto `Any` data to JSON via prost-reflect
2. Fills envelope fields (id, source, time) from event metadata
3. Publishes to configured sinks

---

## Client Usage

Two patterns are available for building CloudEvents projectors:

| Pattern | Best For | State Management |
|---------|----------|------------------|
| **OO-style** | Simple projectors, familiar class-based design | Instance fields |
| **Router** | Complex routing, multiple event types, functional style | Explicit state parameter |

Both patterns work in all supported languages. Choose based on team preference.

### OO-Style (Class-Based)

Implement a projector class with handler methods. State lives in instance fields:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python
from angzarr_client import CloudEventsProjector, CloudEvent
from google.protobuf.any_pb2 import Any

class OrderCloudEventsProjector(CloudEventsProjector):
    """Publishes public order events to external consumers."""

    def __init__(self):
        super().__init__("prj-orders-cloudevents", "orders")

    def on_order_created(self, event: OrderCreated) -> CloudEvent | None:
        # Filter sensitive fields, return public version
        public = PublicOrderCreated(
            order_id=event.order_id,
            total=event.total,
            # Omit: customer_email, payment_details
        )
        data = Any()
        data.Pack(public)
        return CloudEvent(type="com.example.order.created", data=data)

    def on_order_shipped(self, event: OrderShipped) -> CloudEvent | None:
        public = PublicOrderShipped(
            order_id=event.order_id,
            carrier=event.carrier,
        )
        data = Any()
        data.Pack(public)
        return CloudEvent(
            type="com.example.order.shipped",
            data=data,
            extensions={"priority": "high"},
        )
```

</TabItem>
<TabItem value="go" label="Go">

```go
type OrderCloudEventsProjector struct {
    angzarr.CloudEventsProjectorBase
}

func NewOrderCloudEventsProjector() *OrderCloudEventsProjector {
    p := &OrderCloudEventsProjector{}
    p.Init("prj-orders-cloudevents", "orders")
    return p
}

func (p *OrderCloudEventsProjector) OnOrderCreated(event *OrderCreated) *pb.CloudEvent {
    // Filter sensitive fields, return public version
    public := &PublicOrderCreated{
        OrderId: event.OrderId,
        Total:   event.Total,
    }
    data, _ := anypb.New(public)
    return &pb.CloudEvent{
        Type: "com.example.order.created",
        Data: data,
    }
}

func (p *OrderCloudEventsProjector) OnOrderShipped(event *OrderShipped) *pb.CloudEvent {
    public := &PublicOrderShipped{
        OrderId: event.OrderId,
        Carrier: event.Carrier,
    }
    data, _ := anypb.New(public)
    return &pb.CloudEvent{
        Type:       "com.example.order.shipped",
        Data:       data,
        Extensions: map[string]string{"priority": "high"},
    }
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
pub struct OrderCloudEventsProjector;

impl CloudEventsProjector for OrderCloudEventsProjector {
    fn name(&self) -> &str { "prj-orders-cloudevents" }
    fn domain(&self) -> &str { "orders" }
}

impl OrderCloudEventsProjector {
    pub fn on_order_created(&self, event: &OrderCreated) -> Option<CloudEvent> {
        // Filter sensitive fields, return public version
        let public = PublicOrderCreated {
            order_id: event.order_id.clone(),
            total: event.total,
        };
        Some(CloudEvent {
            r#type: "com.example.order.created".into(),
            data: Some(Any::from_msg(&public).ok()?),
            ..Default::default()
        })
    }

    pub fn on_order_shipped(&self, event: &OrderShipped) -> Option<CloudEvent> {
        let public = PublicOrderShipped {
            order_id: event.order_id.clone(),
            carrier: event.carrier.clone(),
        };
        Some(CloudEvent {
            r#type: "com.example.order.shipped".into(),
            data: Some(Any::from_msg(&public).ok()?),
            extensions: [("priority".into(), "high".into())].into(),
            ..Default::default()
        })
    }
}
```

</TabItem>
</Tabs>

### Router Pattern (Functional)

Register handlers with explicit state passing. Better for complex routing or when you prefer functional composition:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python
from angzarr_client import CloudEventsRouter, CloudEvent
from google.protobuf.any_pb2 import Any

def handle_order_created(event: OrderCreated) -> CloudEvent | None:
    public = PublicOrderCreated(order_id=event.order_id, total=event.total)
    data = Any()
    data.Pack(public)
    return CloudEvent(type="com.example.order.created", data=data)

def handle_order_shipped(event: OrderShipped) -> CloudEvent | None:
    public = PublicOrderShipped(order_id=event.order_id, carrier=event.carrier)
    data = Any()
    data.Pack(public)
    return CloudEvent(
        type="com.example.order.shipped",
        data=data,
        extensions={"priority": "high"},
    )

router = (
    CloudEventsRouter("prj-orders-cloudevents", "orders")
    .on("OrderCreated", handle_order_created)
    .on("OrderShipped", handle_order_shipped)
)
```

</TabItem>
<TabItem value="go" label="Go">

```go
func handleOrderCreated(event *OrderCreated) *pb.CloudEvent {
    public := &PublicOrderCreated{OrderId: event.OrderId, Total: event.Total}
    data, _ := anypb.New(public)
    return &pb.CloudEvent{Type: "com.example.order.created", Data: data}
}

func handleOrderShipped(event *OrderShipped) *pb.CloudEvent {
    public := &PublicOrderShipped{OrderId: event.OrderId, Carrier: event.Carrier}
    data, _ := anypb.New(public)
    return &pb.CloudEvent{
        Type:       "com.example.order.shipped",
        Data:       data,
        Extensions: map[string]string{"priority": "high"},
    }
}

router := angzarr.NewCloudEventsRouter("prj-orders-cloudevents", "orders").
    On("OrderCreated", handleOrderCreated).
    On("OrderShipped", handleOrderShipped)
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
fn handle_order_created(event: &OrderCreated) -> Option<CloudEvent> {
    let public = PublicOrderCreated {
        order_id: event.order_id.clone(),
        total: event.total,
    };
    Some(CloudEvent {
        r#type: "com.example.order.created".into(),
        data: Some(Any::from_msg(&public).ok()?),
        ..Default::default()
    })
}

fn handle_order_shipped(event: &OrderShipped) -> Option<CloudEvent> {
    let public = PublicOrderShipped {
        order_id: event.order_id.clone(),
        carrier: event.carrier.clone(),
    };
    Some(CloudEvent {
        r#type: "com.example.order.shipped".into(),
        data: Some(Any::from_msg(&public).ok()?),
        extensions: [("priority".into(), "high".into())].into(),
        ..Default::default()
    })
}

let router = CloudEventsRouter::new("prj-orders-cloudevents", "orders")
    .on::<OrderCreated>(handle_order_created)
    .on::<OrderShipped>(handle_order_shipped);
```

</TabItem>
</Tabs>

### Raw Handle (Low-Level)

For full control over the projection lifecycle, implement the raw handle method:

```rust
async fn handle(&self, events: &EventBook, _mode: ProjectionMode) -> Result<Projection, Status> {
    let mut cloud_events = Vec::new();

    for page in &events.pages {
        if let Some(event) = &page.event {
            if event.type_url.ends_with("OrderCreated") {
                let order = OrderCreated::decode(&event.value[..])?;

                // Create filtered public event
                let public = PublicOrderCreated {
                    order_id: order.order_id.clone(),
                    total: order.total,
                };
                let data = prost_types::Any::from_msg(&public)?;

                cloud_events.push(CloudEvent {
                    r#type: "com.example.order.created".to_string(),
                    data: Some(data),
                    ..Default::default()
                });
            }
        }
    }

    let response = CloudEventsResponse { events: cloud_events };
    let projection_any = prost_types::Any::from_msg(&response)?;

    Ok(Projection {
        cover: events.cover.clone(),
        projector: "prj-orders-cloudevents".to_string(),
        projection: Some(projection_any),
        ..Default::default()
    })
}
```

---

## CloudEvent Proto

```protobuf
message CloudEvent {
  string type = 1;                    // Event type (e.g., "com.example.order.created")
  google.protobuf.Any data = 2;       // Payload (framework converts to JSON)
  map<string, string> extensions = 3; // Custom extension attributes

  // Optional overrides (framework fills defaults from Cover/EventPage)
  optional string id = 4;             // Default: {domain}:{root_id}:{sequence}
  optional string source = 5;         // Default: angzarr/{domain}
  optional string subject = 6;        // Default: aggregate root ID
}

message CloudEventsResponse {
  repeated CloudEvent events = 1;
}
```

---

## Output Format

Framework produces CloudEvents 1.0 JSON:

```json
{
  "specversion": "1.0",
  "id": "orders:abc123def456:5",
  "type": "com.example.order.created",
  "source": "angzarr/orders",
  "time": "2024-01-15T10:30:00Z",
  "datacontenttype": "application/json",
  "subject": "abc123def456",
  "correlationid": "corr-xyz-789",
  "data": {
    "order_id": "ORD-12345",
    "total": 9999
  }
}
```

### Field Defaults

| Field | Default Value | Override |
|-------|--------------|----------|
| `id` | `{domain}:{root_id}:{sequence}` | `CloudEvent.id` |
| `source` | `angzarr/{domain}` | `CloudEvent.source` |
| `subject` | Aggregate root ID (hex) | `CloudEvent.subject` |
| `time` | Event creation timestamp | From EventPage |
| `correlationid` | Cover correlation ID | Auto-added as extension |

---

## Extension Attributes

The framework supports custom [CloudEvents extension attributes](https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md#extension-context-attributes) via the `extensions` map in `CloudEvent`.

### Automatic Lowercasing

Per the CloudEvents spec, extension attribute names **must be lowercase**. The framework automatically lowercases all extension keys, so you can use any case in your client code:

```python
# All of these become "traceid" in the output
CloudEvent(
    type="com.example.order.created",
    extensions={
        "TraceID": "abc123",      # → "traceid"
        "PRIORITY": "high",       # → "priority"
        "customExt": "value",     # → "customext"
    }
)
```

This follows [Postel's Law](https://en.wikipedia.org/wiki/Robustness_principle): _"be tolerant of what you accept, strict in what you emit"_.

### Built-in Extensions

The framework automatically adds:

| Extension | Source | Description |
|-----------|--------|-------------|
| `correlationid` | `Cover.correlation_id` | Cross-domain workflow identifier |

### Validation

The framework uses the official [cloudevents-sdk](https://github.com/cloudevents/sdk-rust) crate for CloudEvents 1.0 validation. Invalid events (missing required fields, malformed URIs, etc.) are rejected with an error rather than silently published.

---

## Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `CLOUDEVENTS_SINK` | Sink type: `http`, `kafka`, or `both` | `http` |
| `CLOUDEVENTS_HTTP_ENDPOINT` | Webhook URL | Required if http |
| `CLOUDEVENTS_HTTP_TIMEOUT` | Request timeout (seconds) | `30` |
| `CLOUDEVENTS_BATCH_SIZE` | Max events per HTTP request | `100` |
| `CLOUDEVENTS_KAFKA_BROKERS` | Kafka bootstrap servers | Required if kafka |
| `CLOUDEVENTS_KAFKA_TOPIC` | Kafka topic name | `cloudevents` |
| `CLOUDEVENTS_KAFKA_TIMEOUT` | Delivery timeout (seconds) | `5` |

### Kafka Authentication

| Variable | Description |
|----------|-------------|
| `CLOUDEVENTS_KAFKA_SASL_USERNAME` | SASL username |
| `CLOUDEVENTS_KAFKA_SASL_PASSWORD` | SASL password |
| `CLOUDEVENTS_KAFKA_SASL_MECHANISM` | `PLAIN`, `SCRAM-SHA-256`, `SCRAM-SHA-512` |
| `CLOUDEVENTS_KAFKA_SECURITY_PROTOCOL` | `PLAINTEXT`, `SSL`, `SASL_PLAINTEXT`, `SASL_SSL` |
| `CLOUDEVENTS_KAFKA_SSL_CA` | SSL CA certificate path |

---

## HTTP Sink

POSTs batches using `application/cloudevents-batch+json` content type:

```http
POST /events HTTP/1.1
Host: webhook.example.com
Content-Type: application/cloudevents-batch+json

[
  {"specversion": "1.0", "id": "...", "type": "...", "data": {...}},
  {"specversion": "1.0", "id": "...", "type": "...", "data": {...}}
]
```

**Retry behavior:**
- Retries on: connection errors, timeouts, 429 (rate limit), 5xx (server errors)
- Exponential backoff: 100ms → 5s max, 5 attempts
- No retry on: 4xx client errors (except 429)

---

## Kafka Sink

Publishes JSON-serialized CloudEvents with:
- **Message key**: `subject` field (aggregate root ID) for ordering
- **Idempotent producer**: Enabled by default
- **Acks**: `all` (wait for ISR acknowledgment)

---

## Filtering Sensitive Data

CloudEvents are public-facing. Always create "public" proto messages that exclude:
- PII (emails, phone numbers, addresses)
- Payment details (card numbers, bank accounts)
- Internal IDs and implementation details
- Authentication tokens or secrets

```python
# Internal event (has sensitive data)
class OrderCreated:
    order_id: str
    customer_email: str      # PII
    payment_token: str       # Secret
    total: int
    internal_notes: str      # Internal

# Public event (safe to expose)
class PublicOrderCreated:
    order_id: str
    total: int
```

---

## Multiple Events per Source Event

A single source event can produce multiple CloudEvents (fan-out):

```python
def transform_events(event_book):
    cloud_events = []

    for page in event_book.pages:
        if page.event.type_url.endswith("OrderCreated"):
            order = unpack(page.event)

            # Event for order tracking
            cloud_events.append(CloudEvent(
                type="com.example.order.created",
                data=pack(OrderPublic(order_id=order.order_id)),
            ))

            # Event for each line item (inventory systems)
            for item in order.items:
                cloud_events.append(CloudEvent(
                    type="com.example.lineitem.ordered",
                    data=pack(LineItemPublic(sku=item.sku, quantity=item.qty)),
                ))

    return pack_response(cloud_events)
```

---

## Skipping Events

Return an empty `CloudEventsResponse` to skip publishing:

```python
def transform_events(event_book):
    cloud_events = []

    for page in event_book.pages:
        # Only publish certain event types
        if page.event.type_url.endswith("OrderShipped"):
            cloud_events.append(...)

    # If no events match, returns empty response (nothing published)
    return pack_response(cloud_events)
```

---

## Framework Integration (Rust)

For direct framework usage (not via client projector):

```rust
use angzarr::handlers::projectors::{
    CloudEventsCoordinator, HttpSink, HttpSinkConfig, NullSink
};

// Create HTTP sink
let sink = HttpSink::new(
    HttpSinkConfig::default()
        .with_endpoint("https://webhook.example.com/events".to_string())
        .with_timeout(Duration::from_secs(30))
)?;

// Create coordinator
let coordinator = CloudEventsCoordinator::new(Arc::new(sink));

// Process projection (returns true if CloudEventsResponse was detected)
let was_cloudevents = coordinator.process(&projection, Some(&source_events)).await?;
```

---

## Next Steps

- **[Projectors](/components/projector)** — Projector patterns and StateRouter
- **[Framework Projectors](/components/framework-projectors)** — Other built-in projectors
