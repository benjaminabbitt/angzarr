---
sidebar_position: 6
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# CloudEvents Projector

The **CloudEvents projector** transforms internal domain events into [CloudEvents 1.0](https://cloudevents.io/) format and publishes them to external systems via HTTP webhooks or Kafka.

This enables event-driven integrations where external consumers (partner APIs, analytics pipelines, notification services) receive filtered, public-facing events without accessing internal event stores.

---

## Architecture

```
                    Client Code                        Framework
                    ───────────                        ─────────
EventBook ──→ [ProjectorHandler] ──→ Projection ──→ [CloudEventsCoordinator] ──→ Sink
              (filters/transforms)    (CloudEventsResponse           (HTTP/Kafka)
                                       packed in .projection)
```

**Client projectors** use existing projector libraries (`ProjectorHandler`, `StateRouter`) to:
1. Receive internal events
2. Filter sensitive fields (create "public" versions)
3. Pack `CloudEventsResponse` into `Projection.projection`

**Framework coordinator** detects `CloudEventsResponse` by type URL and:
1. Converts proto `Any` data to JSON via prost-reflect
2. Fills envelope fields (id, source, time) from event metadata
3. Publishes to configured sinks

---

## Client Usage

Two patterns are available for building CloudEvents projectors:

| Pattern | Best For | State Management |
|---------|----------|------------------|
| **OO-style** | Simple projectors, familiar class-based design | Instance fields |
| **Router** | Complex routing, multiple event types, functional style | Explicit state parameter |

Both patterns work in all supported languages. Choose based on team preference.

### OO-Style (Class-Based)

Implement a projector class with handler methods. State lives in instance fields:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python file=examples/python/prj-cloudevents/cloudevents_projector.py start=docs:start:cloudevents_oo end=docs:end:cloudevents_oo
```

</TabItem>
<TabItem value="go" label="Go">

```go file=examples/go/prj-cloudevents/main.go start=docs:start:cloudevents_oo end=docs:end:cloudevents_oo
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust file=examples/rust/prj-cloudevents/src/main.rs start=docs:start:cloudevents_oo end=docs:end:cloudevents_oo
```

</TabItem>
<TabItem value="java" label="Java">

```java file=examples/java/prj-cloudevents/src/main/java/dev/angzarr/examples/prjcloudevents/PlayerCloudEventsProjector.java start=docs:start:cloudevents_oo end=docs:end:cloudevents_oo
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp file=examples/csharp/Prj/CloudEvents/PlayerCloudEventsProjector.cs start=docs:start:cloudevents_oo end=docs:end:cloudevents_oo
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp file=examples/cpp/prj-cloudevents/src/cloudevents_projector.cpp start=docs:start:cloudevents_oo end=docs:end:cloudevents_oo
```

</TabItem>
</Tabs>

### Router Pattern (Functional)

Register handlers with explicit state passing. Better for complex routing or when you prefer functional composition:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python file=examples/python/prj-cloudevents/cloudevents_projector.py start=docs:start:cloudevents_router end=docs:end:cloudevents_router
```

</TabItem>
<TabItem value="go" label="Go">

```go file=examples/go/prj-cloudevents/main.go start=docs:start:cloudevents_router end=docs:end:cloudevents_router
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust file=examples/rust/prj-cloudevents/src/main.rs start=docs:start:cloudevents_router end=docs:end:cloudevents_router
```

</TabItem>
<TabItem value="java" label="Java">

```java file=examples/java/prj-cloudevents/src/main/java/dev/angzarr/examples/prjcloudevents/PlayerCloudEventsRouter.java start=docs:start:cloudevents_router end=docs:end:cloudevents_router
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp file=examples/csharp/Prj/CloudEvents/PlayerCloudEventsProjector.cs start=docs:start:cloudevents_router end=docs:end:cloudevents_router
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp file=examples/cpp/prj-cloudevents/src/cloudevents_projector.cpp start=docs:start:cloudevents_router end=docs:end:cloudevents_router
```

</TabItem>
</Tabs>

### Raw Handle (Low-Level)

For full control over the projection lifecycle, implement the raw handle method:

```rust
async fn handle(&self, events: &EventBook, _mode: ProjectionMode) -> Result<Projection, Status> {
    let mut cloud_events = Vec::new();

    for page in &events.pages {
        if let Some(event) = &page.event {
            if event.type_url.ends_with("OrderCreated") {
                let order = OrderCreated::decode(&event.value[..])?;

                // Create filtered public event
                let public = PublicOrderCreated {
                    order_id: order.order_id.clone(),
                    total: order.total,
                };
                let data = prost_types::Any::from_msg(&public)?;

                cloud_events.push(CloudEvent {
                    r#type: "com.example.order.created".to_string(),
                    data: Some(data),
                    ..Default::default()
                });
            }
        }
    }

    let response = CloudEventsResponse { events: cloud_events };
    let projection_any = prost_types::Any::from_msg(&response)?;

    Ok(Projection {
        cover: events.cover.clone(),
        projector: "prj-orders-cloudevents".to_string(),
        projection: Some(projection_any),
        ..Default::default()
    })
}
```

---

## CloudEvent Proto

```protobuf
message CloudEvent {
  string type = 1;                    // Event type (e.g., "com.example.order.created")
  google.protobuf.Any data = 2;       // Payload (framework converts to JSON)
  map<string, string> extensions = 3; // Custom extension attributes

  // Optional overrides (framework fills defaults from Cover/EventPage)
  optional string id = 4;             // Default: {domain}:{root_id}:{sequence}
  optional string source = 5;         // Default: angzarr/{domain}
  optional string subject = 6;        // Default: aggregate root ID
}

message CloudEventsResponse {
  repeated CloudEvent events = 1;
}
```

---

## Output Format

Framework produces CloudEvents 1.0 JSON:

```json
{
  "specversion": "1.0",
  "id": "orders:abc123def456:5",
  "type": "com.example.order.created",
  "source": "angzarr/orders",
  "time": "2024-01-15T10:30:00Z",
  "datacontenttype": "application/json",
  "subject": "abc123def456",
  "correlationid": "corr-xyz-789",
  "data": {
    "order_id": "ORD-12345",
    "total": 9999
  }
}
```

### Field Defaults

| Field | Default Value | Override |
|-------|--------------|----------|
| `id` | `{domain}:{root_id}:{sequence}` | `CloudEvent.id` |
| `source` | `angzarr/{domain}` | `CloudEvent.source` |
| `subject` | Aggregate root ID (hex) | `CloudEvent.subject` |
| `time` | Event creation timestamp | From EventPage |
| `correlationid` | Cover correlation ID | Auto-added as extension |

---

## Extension Attributes

The framework supports custom [CloudEvents extension attributes](https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md#extension-context-attributes) via the `extensions` map in `CloudEvent`.

### Automatic Lowercasing

Per the CloudEvents spec, extension attribute names **must be lowercase**. The framework automatically lowercases all extension keys, so you can use any case in your client code:

```python
# All of these become "traceid" in the output
CloudEvent(
    type="com.example.order.created",
    extensions={
        "TraceID": "abc123",      # → "traceid"
        "PRIORITY": "high",       # → "priority"
        "customExt": "value",     # → "customext"
    }
)
```

This follows [Postel's Law](https://en.wikipedia.org/wiki/Robustness_principle): _"be tolerant of what you accept, strict in what you emit"_.

### Built-in Extensions

The framework automatically adds:

| Extension | Source | Description |
|-----------|--------|-------------|
| `correlationid` | `Cover.correlation_id` | Cross-domain workflow identifier |

### Validation

The framework uses the official [cloudevents-sdk](https://github.com/cloudevents/sdk-rust) crate for CloudEvents 1.0 validation. Invalid events (missing required fields, malformed URIs, etc.) are rejected with an error rather than silently published.

---

## Configuration

### Environment Variables

| Variable | Description | Default |
|----------|-------------|---------|
| `CLOUDEVENTS_SINK` | Sink type: `http`, `kafka`, or `both` | `http` |
| `CLOUDEVENTS_HTTP_ENDPOINT` | Webhook URL | Required if http |
| `CLOUDEVENTS_HTTP_TIMEOUT` | Request timeout (seconds) | `30` |
| `CLOUDEVENTS_BATCH_SIZE` | Max events per HTTP request | `100` |
| `CLOUDEVENTS_KAFKA_BROKERS` | Kafka bootstrap servers | Required if kafka |
| `CLOUDEVENTS_KAFKA_TOPIC` | Kafka topic name | `cloudevents` |
| `CLOUDEVENTS_KAFKA_TIMEOUT` | Delivery timeout (seconds) | `5` |

### Kafka Authentication

| Variable | Description |
|----------|-------------|
| `CLOUDEVENTS_KAFKA_SASL_USERNAME` | SASL username |
| `CLOUDEVENTS_KAFKA_SASL_PASSWORD` | SASL password |
| `CLOUDEVENTS_KAFKA_SASL_MECHANISM` | `PLAIN`, `SCRAM-SHA-256`, `SCRAM-SHA-512` |
| `CLOUDEVENTS_KAFKA_SECURITY_PROTOCOL` | `PLAINTEXT`, `SSL`, `SASL_PLAINTEXT`, `SASL_SSL` |
| `CLOUDEVENTS_KAFKA_SSL_CA` | SSL CA certificate path |

---

## HTTP Sink

POSTs batches using `application/cloudevents-batch+json` content type:

```http
POST /events HTTP/1.1
Host: webhook.example.com
Content-Type: application/cloudevents-batch+json

[
  {"specversion": "1.0", "id": "...", "type": "...", "data": {...}},
  {"specversion": "1.0", "id": "...", "type": "...", "data": {...}}
]
```

**Retry behavior:**
- Retries on: connection errors, timeouts, 429 (rate limit), 5xx (server errors)
- Exponential backoff: 100ms → 5s max, 5 attempts
- No retry on: 4xx client errors (except 429)

---

## Kafka Sink

Publishes JSON-serialized CloudEvents with:
- **Message key**: `subject` field (aggregate root ID) for ordering
- **Idempotent producer**: Enabled by default
- **Acks**: `all` (wait for ISR acknowledgment)

---

## Filtering Sensitive Data

CloudEvents are public-facing. Always create "public" proto messages that exclude:
- PII (emails, phone numbers, addresses)
- Payment details (card numbers, bank accounts)
- Internal IDs and implementation details
- Authentication tokens or secrets

```python
# Internal event (has sensitive data)
class OrderCreated:
    order_id: str
    customer_email: str      # PII
    payment_token: str       # Secret
    total: int
    internal_notes: str      # Internal

# Public event (safe to expose)
class PublicOrderCreated:
    order_id: str
    total: int
```

---

## Multiple Events per Source Event

A single source event can produce multiple CloudEvents (fan-out):

```python
def transform_events(event_book):
    cloud_events = []

    for page in event_book.pages:
        if page.event.type_url.endswith("OrderCreated"):
            order = unpack(page.event)

            # Event for order tracking
            cloud_events.append(CloudEvent(
                type="com.example.order.created",
                data=pack(OrderPublic(order_id=order.order_id)),
            ))

            # Event for each line item (inventory systems)
            for item in order.items:
                cloud_events.append(CloudEvent(
                    type="com.example.lineitem.ordered",
                    data=pack(LineItemPublic(sku=item.sku, quantity=item.qty)),
                ))

    return pack_response(cloud_events)
```

---

## Skipping Events

Return an empty `CloudEventsResponse` to skip publishing:

```python
def transform_events(event_book):
    cloud_events = []

    for page in event_book.pages:
        # Only publish certain event types
        if page.event.type_url.endswith("OrderShipped"):
            cloud_events.append(...)

    # If no events match, returns empty response (nothing published)
    return pack_response(cloud_events)
```

---

## Framework Integration (Rust)

For direct framework usage (not via client projector):

```rust
use angzarr::handlers::projectors::{
    CloudEventsCoordinator, HttpSink, HttpSinkConfig, NullSink
};

// Create HTTP sink
let sink = HttpSink::new(
    HttpSinkConfig::default()
        .with_endpoint("https://webhook.example.com/events".to_string())
        .with_timeout(Duration::from_secs(30))
)?;

// Create coordinator
let coordinator = CloudEventsCoordinator::new(Arc::new(sink));

// Process projection (returns true if CloudEventsResponse was detected)
let was_cloudevents = coordinator.process(&projection, Some(&source_events)).await?;
```

---

## Next Steps

- **[Projectors](/components/projector)** — Projector patterns and StateRouter
- **[Framework Projectors](/components/framework-projectors)** — Other built-in projectors
