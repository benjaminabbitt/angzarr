---
sidebar_position: 2
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Aggregates

A **command handler** (also called **aggregate**) processes commands for a domain, validates business rules against current state, and emits events. This is the consistency boundary for domain objects.

There is exactly **one aggregate codebase per domain**. The "player" domain has one aggregate that handles all player-related commands (RegisterPlayer, DepositFunds, ReserveFunds, etc.). This single codebase scales horizontally across many processes.

---

## Handler Pattern: guard/validate/compute

All aggregate command handlers follow a three-function pattern that makes business logic **100% unit testable** without mocking:

| Step | Purpose | Pure Function |
|------|---------|---------------|
| **guard(state)** | Check state preconditions (aggregate exists, correct phase) | state → Result |
| **validate(cmd, state)** | Validate command inputs against state | cmd + state → Result |
| **compute(cmd, state)** | Build the resulting event | cmd + state → Event |

The public `handle_*` function is thin orchestration: unpack protobuf, call guard → validate → compute, pack event.

---

## Example: Deposit Handler

### Guard

Checks state preconditions before processing:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python file=examples/python/player/agg/handlers/player.py start=docs:start:deposit_guard end=docs:end:deposit_guard
```

</TabItem>
<TabItem value="go" label="Go">

```go file=examples/go/player/agg/handlers/deposit.go start=docs:start:deposit_guard end=docs:end:deposit_guard
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust file=examples/rust/player/agg/src/handlers/deposit.rs start=docs:start:deposit_guard end=docs:end:deposit_guard
```

</TabItem>
<TabItem value="java" label="Java">

```java file=examples/java/player/agg/src/main/java/dev/angzarr/examples/player/handlers/DepositHandler.java start=docs:start:deposit_guard end=docs:end:deposit_guard
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp file=examples/csharp/Player/Agg/Handlers/DepositHandler.cs start=docs:start:deposit_guard end=docs:end:deposit_guard
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp file=examples/cpp/player/agg/handlers/deposit_handler.cpp start=docs:start:deposit_guard end=docs:end:deposit_guard
```

</TabItem>
</Tabs>

### Validate

Validates command inputs and extracts validated data:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python file=examples/python/player/agg/handlers/player.py start=docs:start:deposit_validate end=docs:end:deposit_validate
```

</TabItem>
<TabItem value="go" label="Go">

```go file=examples/go/player/agg/handlers/deposit.go start=docs:start:deposit_validate end=docs:end:deposit_validate
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust file=examples/rust/player/agg/src/handlers/deposit.rs start=docs:start:deposit_validate end=docs:end:deposit_validate
```

</TabItem>
<TabItem value="java" label="Java">

```java file=examples/java/player/agg/src/main/java/dev/angzarr/examples/player/handlers/DepositHandler.java start=docs:start:deposit_validate end=docs:end:deposit_validate
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp file=examples/csharp/Player/Agg/Handlers/DepositHandler.cs start=docs:start:deposit_validate end=docs:end:deposit_validate
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp file=examples/cpp/player/agg/handlers/deposit_handler.cpp start=docs:start:deposit_validate end=docs:end:deposit_validate
```

</TabItem>
</Tabs>

### Compute

Builds the resulting event from validated inputs:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python file=examples/python/player/agg/handlers/player.py start=docs:start:deposit_compute end=docs:end:deposit_compute
```

</TabItem>
<TabItem value="go" label="Go">

```go file=examples/go/player/agg/handlers/deposit.go start=docs:start:deposit_compute end=docs:end:deposit_compute
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust file=examples/rust/player/agg/src/handlers/deposit.rs start=docs:start:deposit_compute end=docs:end:deposit_compute
```

</TabItem>
<TabItem value="java" label="Java">

```java file=examples/java/player/agg/src/main/java/dev/angzarr/examples/player/handlers/DepositHandler.java start=docs:start:deposit_compute end=docs:end:deposit_compute
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp file=examples/csharp/Player/Agg/Handlers/DepositHandler.cs start=docs:start:deposit_compute end=docs:end:deposit_compute
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp file=examples/cpp/player/agg/handlers/deposit_handler.cpp start=docs:start:deposit_compute end=docs:end:deposit_compute
```

</TabItem>
</Tabs>

---

## State Reconstruction

State is rebuilt by applying events in sequence:

```
Prior Events:
  [0] PlayerRegistered { username: "Alice", initial_bankroll: 1000 }
  [1] FundsDeposited { amount: 500, new_bankroll: 1500 }
  [2] FundsReserved { amount: 200, new_available: 1300, new_reserved: 200 }

Rebuild:
  state = PlayerState::default()
  apply(PlayerRegistered) → state.registered = true, state.bankroll = 1000
  apply(FundsDeposited) → state.bankroll = 1500
  apply(FundsReserved) → state.reserved = 200, state.available = 1300

Result:
  PlayerState { registered: true, bankroll: 1500, reserved: 200, available: 1300 }
```

---

## Unit Testing

Each function is testable in isolation:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python
def test_deposit_increases_bankroll():
    state = PlayerState(registered=True, bankroll=1000)
    cmd = DepositFunds(amount=500)

    event = compute_deposit(cmd, state)

    assert event.new_bankroll == 1500
```

</TabItem>
<TabItem value="go" label="Go">

```go
func TestDepositIncreasesBankroll(t *testing.T) {
    state := &PlayerState{Registered: true, Bankroll: 1000}
    cmd := &DepositFunds{Amount: 500}

    event := computeDeposit(cmd, state)

    assert.Equal(t, int32(1500), event.NewBankroll)
}
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust
#[test]
fn test_deposit_increases_bankroll() {
    let state = PlayerState { registered: true, bankroll: 1000, ..Default::default() };
    let cmd = DepositFunds { amount: 500 };

    let event = compute_deposit(&cmd, &state);

    assert_eq!(event.new_bankroll, 1500);
}
```

</TabItem>
<TabItem value="java" label="Java">

```java
@Test
void testDepositIncreasesBankroll() {
    PlayerState state = new PlayerState();
    state.registered = true;
    state.bankroll = 1000;

    DepositFunds cmd = DepositFunds.newBuilder().setAmount(500).build();

    FundsDeposited event = computeDeposit(cmd, state);

    assertEquals(1500, event.getNewBankroll());
}
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp
[Fact]
public void TestDepositIncreasesBankroll()
{
    var state = new PlayerState { Registered = true, Bankroll = 1000 };
    var cmd = new DepositFunds { Amount = 500 };

    var @event = ComputeDeposit(cmd, state);

    Assert.Equal(1500, @event.NewBankroll);
}
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp
TEST(DepositTest, IncreasesBankroll) {
    PlayerState state;
    state.registered = true;
    state.bankroll = 1000;

    DepositFunds cmd;
    cmd.set_amount(500);

    FundsDeposited event = compute_deposit(cmd, state);

    EXPECT_EQ(event.new_bankroll(), 1500);
}
```

</TabItem>
</Tabs>

---

## CommandRouter

Use the `CommandRouter` to register handlers and dispatch commands:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python file=examples/python/player/agg/main.py start=docs:start:command_router end=docs:end:command_router
```

</TabItem>
<TabItem value="go" label="Go">

```go file=examples/go/player/agg/main.go start=docs:start:command_router end=docs:end:command_router
```

</TabItem>
<TabItem value="rust" label="Rust">

```rust file=examples/rust/player/agg/src/main.rs start=docs:start:command_router end=docs:end:command_router
```

</TabItem>
<TabItem value="java" label="Java">

```java file=examples/java/player/agg/src/main/java/dev/angzarr/examples/player/PlayerRouter.java start=docs:start:command_router end=docs:end:command_router
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp file=examples/csharp/Player/Agg/PlayerRouter.cs start=docs:start:command_router end=docs:end:command_router
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp file=examples/cpp/player/agg/src/main.cpp start=docs:start:command_router end=docs:end:command_router
```

</TabItem>
</Tabs>

### OO Alternative: Aggregate Base Class

All languages also support an OO approach where handlers are methods on an `Aggregate` subclass, using decorators/attributes/macros for dispatch:

<Tabs groupId="language">
<TabItem value="python" label="Python" default>

```python file=examples/python/player/agg/handlers/player.py start=docs:start:annotation_handlers end=docs:end:annotation_handlers
```

</TabItem>
<TabItem value="java" label="Java">

```java file=examples/java/player/agg/src/main/java/dev/angzarr/examples/player/Player.java start=docs:start:annotation_handlers end=docs:end:annotation_handlers
```

</TabItem>
<TabItem value="csharp" label="C#">

```csharp file=examples/csharp/Player/Agg/Player.cs start=docs:start:annotation_handlers end=docs:end:annotation_handlers
```

</TabItem>
<TabItem value="cpp" label="C++">

```cpp file=examples/cpp/player/agg/src/player.cpp start=docs:start:oo_handlers end=docs:end:oo_handlers
```

</TabItem>
<TabItem value="go" label="Go">

Go uses method chaining on `AggregateBase` rather than struct tags:

```go file=examples/go/hand/agg/hand.go start=docs:start:oo_handlers end=docs:end:oo_handlers
```

</TabItem>
<TabItem value="rust" label="Rust">

Rust uses proc macros on impl blocks:

```rust file=examples/rust/table/agg-oo/src/main.rs start=docs:start:oo_handlers end=docs:end:oo_handlers
```

</TabItem>
</Tabs>

Both patterns produce identical behavior—choose based on team preference. The functional `CommandRouter` is more explicit; the OO approach integrates state and handlers in one class.

---

## Event Sequencing

Each event has a `sequence` field. The aggregate computes the next sequence from prior events:

```python
def next_sequence(event_book: EventBook) -> int:
    if event_book.pages:
        return event_book.pages[-1].sequence + 1
    if event_book.snapshot:
        return event_book.snapshot.sequence + 1
    return 0
```

Events with incorrect sequences are rejected (optimistic concurrency control).

---

## Snapshots

For aggregates with many events, enable snapshots to avoid full replay:

1. Define state as a protobuf message
2. Return the updated state in `EventBook.snapshot_state`
3. Angzarr persists snapshots automatically

On subsequent commands, only events after the snapshot are loaded.

---

## Next Steps

- **[Sagas](/components/saga)** — Cross-domain command orchestration
- **[Projectors](/components/projector)** — Building read models
- **[Testing](/operations/testing)** — Three-level testing strategy
