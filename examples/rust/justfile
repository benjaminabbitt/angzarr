# Rust example gRPC servers for angzarr e-commerce domain
# Services: inventory, order, fulfillment
# Sagas: saga-fulfillment, saga-inventory-reservation
# Process Managers: process-manager-fulfillment
# Projectors: projector-inventory
#
# Deployment Model:
#   - Backing services (PostgreSQL, RabbitMQ): Deployed via Terraform/Helm (see root justfile)
#   - Application services: Deployed via Skaffold (this justfile)
#
# For integration/acceptance tests, run from root: `just integration` or `just acceptance`
# This ensures backing services are deployed first via Terraform.

set shell := ["bash", "-c"]

TOP := `git rev-parse --show-toplevel`
IMAGE_TAG := "latest"
REGISTRY_PORT := "5001"

# Show available commands
default:
    @just --list

# ============================================================================
# Build / Test / Clean (workspace-level)
# ============================================================================

# Build all Rust example crates (includes angzarr with sqlite)
build:
    cargo build --workspace --features sqlite

# Run unit tests (inline lib tests, no cluster required)
test:
    cargo test --workspace --lib

# Run integration tests (assumes backing services already deployed via root `just infra`)
# Deploy application services via Skaffold, then run technical tests
integration:
    skaffold run
    @echo "Waiting for application services to be ready..."
    @kubectl wait --for=condition=ready pod -l app.kubernetes.io/component=aggregate -n angzarr --timeout=300s || true
    ANGZARR_PORT=9084 \
    TEST_LANGUAGE=rust cargo test --test container_integration --manifest-path "{{TOP}}/Cargo.toml"

# Run acceptance tests (assumes backing services already deployed via root `just infra`)
# Deploy application services via Skaffold, then run E2E cucumber tests in gateway mode
acceptance:
    @uv run "{{TOP}}/scripts/reset_event_store.py"
    skaffold run
    @echo "Waiting for application services to be ready..."
    @kubectl wait --for=condition=ready pod -l app.kubernetes.io/component=aggregate -n angzarr --timeout=300s || true
    @kubectl wait --for=condition=ready pod -l app.kubernetes.io/component=saga -n angzarr --timeout=300s || true
    ANGZARR_TEST_MODE=gateway \
    ANGZARR_ENDPOINT=http://localhost:9084 \
    cargo test -p e2e --test acceptance

# Clean build artifacts
clean:
    cargo clean

# Format all code
fmt:
    cargo fmt --all

# Lint all code
lint:
    cargo clippy --workspace -- -D warnings

# Lint Helm chart
helm-lint:
    helm lint helm

# ============================================================================
# Container Images
# ============================================================================

# Build all Rust example images (uses multi-stage Containerfile)
images:
    podman build --target builder -f Containerfile "{{TOP}}"
    podman build --target inventory -t localhost:{{REGISTRY_PORT}}/aggregate-inventory-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"
    podman build --target order -t localhost:{{REGISTRY_PORT}}/aggregate-order-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"
    podman build --target fulfillment -t localhost:{{REGISTRY_PORT}}/aggregate-fulfillment-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"
    podman build --target saga-order-fulfillment -t localhost:{{REGISTRY_PORT}}/saga-order-fulfillment-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"
    podman build --target saga-order-inventory -t localhost:{{REGISTRY_PORT}}/saga-order-inventory-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"
    podman build --target saga-fulfillment-inventory -t localhost:{{REGISTRY_PORT}}/saga-fulfillment-inventory-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"
    podman build --target process-manager-fulfillment -t localhost:{{REGISTRY_PORT}}/process-manager-fulfillment-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"
    podman build --target projector-inventory -t localhost:{{REGISTRY_PORT}}/projector-inventory-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"

# Build a single service image
image SERVICE:
    podman build --target {{SERVICE}} -t localhost:{{REGISTRY_PORT}}/entity-{{SERVICE}}-rs:{{IMAGE_TAG}} -f Containerfile "{{TOP}}"

# Push all images to local registry
push:
    podman push localhost:{{REGISTRY_PORT}}/aggregate-inventory-rs:{{IMAGE_TAG}} --tls-verify=false
    podman push localhost:{{REGISTRY_PORT}}/aggregate-order-rs:{{IMAGE_TAG}} --tls-verify=false
    podman push localhost:{{REGISTRY_PORT}}/aggregate-fulfillment-rs:{{IMAGE_TAG}} --tls-verify=false
    podman push localhost:{{REGISTRY_PORT}}/saga-order-fulfillment-rs:{{IMAGE_TAG}} --tls-verify=false
    podman push localhost:{{REGISTRY_PORT}}/saga-order-inventory-rs:{{IMAGE_TAG}} --tls-verify=false
    podman push localhost:{{REGISTRY_PORT}}/saga-fulfillment-inventory-rs:{{IMAGE_TAG}} --tls-verify=false
    podman push localhost:{{REGISTRY_PORT}}/process-manager-fulfillment-rs:{{IMAGE_TAG}} --tls-verify=false
    podman push localhost:{{REGISTRY_PORT}}/projector-inventory-rs:{{IMAGE_TAG}} --tls-verify=false

# ============================================================================
# Skaffold Development (recommended workflow)
# ============================================================================
#
# UNIFIED WORKFLOW:
#   just dev    - watch mode, rebuilds on file change (framework + business)
#   just run    - build and deploy once
#
# All 12 images (5 framework + 7 business) are built with sha256 tags.
# Skaffold caches aggressively - only changed images are rebuilt.
#
# With lefthook: commits automatically trigger deployment (see lefthook.yml)

# One-time setup: configure Podman and Skaffold for local registry
setup:
    @echo "Configuring Podman for local registry..."
    @uv run "{{TOP}}/scripts/configure_podman_registry.py"
    @echo "Configuring Skaffold for Kind..."
    @uv run "{{TOP}}/scripts/configure_skaffold.py"
    uv run "{{TOP}}/scripts/kind-with-registry.py"

# Start skaffold dev loop (watches files, rebuilds on change)
# Builds all 12 images (framework + business) via 'requires' directive
dev: setup
    cd "{{TOP}}" && just secrets-init
    @echo "=== Skaffold Dev Mode ==="
    @echo "Building all images (5 framework + 7 business) with sha256 tags"
    @echo "Only changed images will be rebuilt (skaffold caching)"
    @echo ""
    skaffold dev

# Build and deploy once
run: setup
    cd "{{TOP}}" && just secrets-init
    @echo "=== Skaffold Deploy ==="
    @echo "Building all images with sha256 tags"
    skaffold run

# Build images only (no deploy)
build-images:
    skaffold build

# Delete deployed resources
delete:
    skaffold delete

# ============================================================================
# Embedded Mode (Local Development with UDS)
# Runs all services via angzarr-standalone orchestrator
# ============================================================================

# Build angzarr binaries for standalone mode
build-angzarr:
    cd {{TOP}} && cargo build --features sqlite --bin angzarr-aggregate --bin angzarr-saga --bin angzarr-projector --bin angzarr-gateway --bin angzarr-standalone

# Clean up stale UDS sockets
clean-sockets:
    mkdir -p /tmp/angzarr
    rm -f /tmp/angzarr/*.sock 2>/dev/null || true

# Run a single aggregate service with its sidecar using UDS
run-aggregate DOMAIN: build-angzarr build
    #!/usr/bin/env bash
    set -e
    mkdir -p /tmp/angzarr
    export TRANSPORT_TYPE=uds
    export UDS_BASE_PATH=/tmp/angzarr
    export ANGZARR_CONFIG=config/standalone.yaml
    export SERVICE_NAME=business
    export DOMAIN={{DOMAIN}}
    
    # Start client logic in background
    # It will listen on $UDS_BASE_PATH/business-$DOMAIN.sock
    ./target/debug/{{DOMAIN}}-server &
    BUSINESS_PID=$!
    
    # Start angzarr sidecar
    # It will listen on $UDS_BASE_PATH/aggregate-$DOMAIN.sock
    # And connect to $UDS_BASE_PATH/business-$DOMAIN.sock
    # Use ANGZARR_DISCOVERY=static to avoid K8s dependencies
    export ANGZARR_DISCOVERY=static
    {{TOP}}/target/debug/angzarr-aggregate --config config/standalone.yaml \
        || kill $BUSINESS_PID
    
    kill $BUSINESS_PID 2>/dev/null || true

# Run a single saga service with its sidecar using UDS
run-saga DOMAIN: build-angzarr build
    #!/usr/bin/env bash
    set -e
    mkdir -p /tmp/angzarr
    export TRANSPORT_TYPE=uds
    export UDS_BASE_PATH=/tmp/angzarr
    export ANGZARR_CONFIG=config/standalone.yaml
    export SERVICE_NAME=saga
    export DOMAIN={{DOMAIN}}
    
    # Start saga logic in background
    # It will listen on $UDS_BASE_PATH/saga-$DOMAIN.sock
    ./target/debug/sag-{{DOMAIN}}-server &
    SAGA_PID=$!
    
    # Start angzarr sidecar
    # It will connect to $UDS_BASE_PATH/saga-$DOMAIN.sock
    # For standalone, we often need static endpoints for two-phase routing
    export ANGZARR_STATIC_ENDPOINTS="order=/tmp/angzarr/aggregate-order.sock,inventory=/tmp/angzarr/aggregate-inventory.sock,fulfillment=/tmp/angzarr/aggregate-fulfillment.sock"
    {{TOP}}/target/debug/angzarr-saga --config config/standalone.yaml \
        || kill $SAGA_PID
    
    kill $SAGA_PID 2>/dev/null || true

# Run a single projector service with its sidecar using UDS
run-projector NAME DOMAIN: build-angzarr build
    #!/usr/bin/env bash
    set -e
    mkdir -p /tmp/angzarr
    export TRANSPORT_TYPE=uds
    export UDS_BASE_PATH=/tmp/angzarr
    export ANGZARR_CONFIG=config/standalone.yaml
    export SERVICE_NAME=projector-{{NAME}}
    export DOMAIN={{DOMAIN}}
    
    # Start projector logic in background
    ./target/debug/prj-{{NAME}}-server &
    PROJ_PID=$!
    
    # Start angzarr sidecar
    {{TOP}}/target/debug/angzarr-projector --config config/standalone.yaml \
        || kill $PROJ_PID
    
    kill $PROJ_PID 2>/dev/null || true

# Run a single process manager service with its sidecar using UDS
run-pm DOMAIN: build-angzarr build
    #!/usr/bin/env bash
    set -e
    mkdir -p /tmp/angzarr
    export TRANSPORT_TYPE=uds
    export UDS_BASE_PATH=/tmp/angzarr
    export ANGZARR_CONFIG=config/standalone.yaml
    export SERVICE_NAME=process-manager
    export DOMAIN={{DOMAIN}}
    
    # Start PM logic in background
    ./target/debug/pmg-{{DOMAIN}}-server &
    PM_PID=$!
    
    # Start angzarr sidecar
    export ANGZARR_STATIC_ENDPOINTS="order=/tmp/angzarr/aggregate-order.sock,inventory=/tmp/angzarr/aggregate-inventory.sock,fulfillment=/tmp/angzarr/aggregate-fulfillment.sock"
    {{TOP}}/target/debug/angzarr-process-manager --config config/standalone.yaml \
        || kill $PM_PID
    
    kill $PM_PID 2>/dev/null || true

# Run all services in standalone mode (single command)
embedded: build-angzarr clean-sockets build
    cd {{TOP}}/examples/rust && ANGZARR_CONFIG=config/standalone.yaml {{TOP}}/target/debug/angzarr-standalone

# Kill any stale embedded processes
kill-embedded:
    #!/usr/bin/env bash
    # Use pgrep to find exact binary matches, then kill
    for proc in angzarr-standalone angzarr-aggregate angzarr-saga angzarr-projector angzarr-gateway; do
        pids=$(pgrep -x "$proc" 2>/dev/null || true)
        if [ -n "$pids" ]; then
            echo "$pids" | xargs kill -9 2>/dev/null || true
        fi
    done
    sleep 1

# Run acceptance tests against embedded mode
# Starts embedded runtime in background, runs tests, cleans up
acceptance-embedded: build-angzarr kill-embedded clean-sockets build
    #!/usr/bin/env bash
    set -e
    cd "{{TOP}}/examples/rust"

    # Cleanup function
    cleanup() {
        echo "Cleaning up..."
        for proc in angzarr-standalone angzarr-aggregate angzarr-saga angzarr-projector angzarr-gateway; do
            pids=$(pgrep -x "$proc" 2>/dev/null || true)
            if [ -n "$pids" ]; then
                echo "$pids" | xargs kill -9 2>/dev/null || true
            fi
        done
        rm -f /tmp/angzarr/*.sock 2>/dev/null || true
    }
    trap cleanup EXIT

    # Start standalone runtime in background
    echo "Starting standalone runtime..."
    ANGZARR_CONFIG=config/standalone.yaml "{{TOP}}/target/debug/angzarr-standalone" &
    EMBEDDED_PID=$!

    # Wait for services to be ready (gateway on port 9084)
    # Use TCP connection check (no reflection needed)
    echo "Waiting for gateway to be ready..."
    for i in {1..60}; do
        if nc -z localhost 9084 2>/dev/null; then
            echo "Gateway ready!"
            break
        fi
        if [ $i -eq 60 ]; then
            echo "Timeout waiting for gateway"
            exit 1
        fi
        sleep 1
    done

    # Run acceptance tests
    echo "Running acceptance tests..."
    ANGZARR_PORT=9084 cargo test --workspace --test acceptance || TEST_RESULT=$?

    exit ${TEST_RESULT:-0}


