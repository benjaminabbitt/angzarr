# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from angzarr import process_manager_pb2 as angzarr_dot_process__manager__pb2
from angzarr import types_pb2 as angzarr_dot_types__pb2


class ProcessManagerServiceStub(object):
    """ProcessManagerService: stateful coordinator for long-running workflows across multiple aggregates.

    WARNING: Only use when saga + queries is insufficient. Consider:
    - Can a simple saga + destination queries solve this?
    - Is the "state" you want to track already derivable from existing aggregates?
    - Are you adding Process Manager because the workflow is genuinely complex?

    Process Manager is warranted when:
    - Workflow state is NOT derivable from aggregates (PM owns unique state)
    - You need to query workflow status independently ("show all pending fulfillments")
    - Timeout/scheduling logic is complex enough to merit its own aggregate
    - You must react to events from MULTIPLE domains (saga recommends single domain)

    Process Manager IS an aggregate with its own domain, events, and state.
    It reuses all aggregate infrastructure (EventStore, SnapshotStore, AggregateCoordinator).
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.GetDescriptor = channel.unary_unary(
                '/angzarr.ProcessManagerService/GetDescriptor',
                request_serializer=angzarr_dot_types__pb2.GetDescriptorRequest.SerializeToString,
                response_deserializer=angzarr_dot_types__pb2.ComponentDescriptor.FromString,
                _registered_method=True)
        self.Prepare = channel.unary_unary(
                '/angzarr.ProcessManagerService/Prepare',
                request_serializer=angzarr_dot_process__manager__pb2.ProcessManagerPrepareRequest.SerializeToString,
                response_deserializer=angzarr_dot_process__manager__pb2.ProcessManagerPrepareResponse.FromString,
                _registered_method=True)
        self.Handle = channel.unary_unary(
                '/angzarr.ProcessManagerService/Handle',
                request_serializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleRequest.SerializeToString,
                response_deserializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleResponse.FromString,
                _registered_method=True)


class ProcessManagerServiceServicer(object):
    """ProcessManagerService: stateful coordinator for long-running workflows across multiple aggregates.

    WARNING: Only use when saga + queries is insufficient. Consider:
    - Can a simple saga + destination queries solve this?
    - Is the "state" you want to track already derivable from existing aggregates?
    - Are you adding Process Manager because the workflow is genuinely complex?

    Process Manager is warranted when:
    - Workflow state is NOT derivable from aggregates (PM owns unique state)
    - You need to query workflow status independently ("show all pending fulfillments")
    - Timeout/scheduling logic is complex enough to merit its own aggregate
    - You must react to events from MULTIPLE domains (saga recommends single domain)

    Process Manager IS an aggregate with its own domain, events, and state.
    It reuses all aggregate infrastructure (EventStore, SnapshotStore, AggregateCoordinator).
    """

    def GetDescriptor(self, request, context):
        """Self-description: component type, subscribed domains, handled event types
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Prepare(self, request, context):
        """Phase 1: Declare which additional destinations are needed beyond the trigger.
        PM automatically receives triggering event's domain state.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Handle(self, request, context):
        """Phase 2: Handle with trigger + process state + fetched destinations.
        Returns commands for other aggregates and events for the PM's own domain.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ProcessManagerServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'GetDescriptor': grpc.unary_unary_rpc_method_handler(
                    servicer.GetDescriptor,
                    request_deserializer=angzarr_dot_types__pb2.GetDescriptorRequest.FromString,
                    response_serializer=angzarr_dot_types__pb2.ComponentDescriptor.SerializeToString,
            ),
            'Prepare': grpc.unary_unary_rpc_method_handler(
                    servicer.Prepare,
                    request_deserializer=angzarr_dot_process__manager__pb2.ProcessManagerPrepareRequest.FromString,
                    response_serializer=angzarr_dot_process__manager__pb2.ProcessManagerPrepareResponse.SerializeToString,
            ),
            'Handle': grpc.unary_unary_rpc_method_handler(
                    servicer.Handle,
                    request_deserializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleRequest.FromString,
                    response_serializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'angzarr.ProcessManagerService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('angzarr.ProcessManagerService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class ProcessManagerService(object):
    """ProcessManagerService: stateful coordinator for long-running workflows across multiple aggregates.

    WARNING: Only use when saga + queries is insufficient. Consider:
    - Can a simple saga + destination queries solve this?
    - Is the "state" you want to track already derivable from existing aggregates?
    - Are you adding Process Manager because the workflow is genuinely complex?

    Process Manager is warranted when:
    - Workflow state is NOT derivable from aggregates (PM owns unique state)
    - You need to query workflow status independently ("show all pending fulfillments")
    - Timeout/scheduling logic is complex enough to merit its own aggregate
    - You must react to events from MULTIPLE domains (saga recommends single domain)

    Process Manager IS an aggregate with its own domain, events, and state.
    It reuses all aggregate infrastructure (EventStore, SnapshotStore, AggregateCoordinator).
    """

    @staticmethod
    def GetDescriptor(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/angzarr.ProcessManagerService/GetDescriptor',
            angzarr_dot_types__pb2.GetDescriptorRequest.SerializeToString,
            angzarr_dot_types__pb2.ComponentDescriptor.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Prepare(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/angzarr.ProcessManagerService/Prepare',
            angzarr_dot_process__manager__pb2.ProcessManagerPrepareRequest.SerializeToString,
            angzarr_dot_process__manager__pb2.ProcessManagerPrepareResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Handle(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/angzarr.ProcessManagerService/Handle',
            angzarr_dot_process__manager__pb2.ProcessManagerHandleRequest.SerializeToString,
            angzarr_dot_process__manager__pb2.ProcessManagerHandleResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)


class ProcessManagerCoordinatorServiceStub(object):
    """ProcessManagerCoordinatorService: orchestrates PM execution
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.HandleSpeculative = channel.unary_unary(
                '/angzarr.ProcessManagerCoordinatorService/HandleSpeculative',
                request_serializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleRequest.SerializeToString,
                response_deserializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleResponse.FromString,
                _registered_method=True)


class ProcessManagerCoordinatorServiceServicer(object):
    """ProcessManagerCoordinatorService: orchestrates PM execution
    """

    def HandleSpeculative(self, request, context):
        """Speculative execution - returns commands and events without persisting
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_ProcessManagerCoordinatorServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'HandleSpeculative': grpc.unary_unary_rpc_method_handler(
                    servicer.HandleSpeculative,
                    request_deserializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleRequest.FromString,
                    response_serializer=angzarr_dot_process__manager__pb2.ProcessManagerHandleResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'angzarr.ProcessManagerCoordinatorService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('angzarr.ProcessManagerCoordinatorService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class ProcessManagerCoordinatorService(object):
    """ProcessManagerCoordinatorService: orchestrates PM execution
    """

    @staticmethod
    def HandleSpeculative(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/angzarr.ProcessManagerCoordinatorService/HandleSpeculative',
            angzarr_dot_process__manager__pb2.ProcessManagerHandleRequest.SerializeToString,
            angzarr_dot_process__manager__pb2.ProcessManagerHandleResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
