// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.1
// - protoc             (unknown)
// source: angzarr/process_manager.proto

package angzarr

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	ProcessManagerService_GetDescriptor_FullMethodName = "/angzarr.ProcessManagerService/GetDescriptor"
	ProcessManagerService_Prepare_FullMethodName       = "/angzarr.ProcessManagerService/Prepare"
	ProcessManagerService_Handle_FullMethodName        = "/angzarr.ProcessManagerService/Handle"
)

// ProcessManagerServiceClient is the client API for ProcessManagerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ProcessManagerService: stateful coordinator for long-running workflows across multiple aggregates.
//
// WARNING: Only use when saga + queries is insufficient. Consider:
// - Can a simple saga + destination queries solve this?
// - Is the "state" you want to track already derivable from existing aggregates?
// - Are you adding Process Manager because the workflow is genuinely complex?
//
// Process Manager is warranted when:
// - Workflow state is NOT derivable from aggregates (PM owns unique state)
// - You need to query workflow status independently ("show all pending fulfillments")
// - Timeout/scheduling logic is complex enough to merit its own aggregate
// - You must react to events from MULTIPLE domains (saga recommends single domain)
//
// Process Manager IS an aggregate with its own domain, events, and state.
// It reuses all aggregate infrastructure (EventStore, SnapshotStore, AggregateCoordinator).
type ProcessManagerServiceClient interface {
	// Self-description: component type, subscribed domains, handled event types
	GetDescriptor(ctx context.Context, in *GetDescriptorRequest, opts ...grpc.CallOption) (*ComponentDescriptor, error)
	// Phase 1: Declare which additional destinations are needed beyond the trigger.
	// PM automatically receives triggering event's domain state.
	Prepare(ctx context.Context, in *ProcessManagerPrepareRequest, opts ...grpc.CallOption) (*ProcessManagerPrepareResponse, error)
	// Phase 2: Handle with trigger + process state + fetched destinations.
	// Returns commands for other aggregates and events for the PM's own domain.
	Handle(ctx context.Context, in *ProcessManagerHandleRequest, opts ...grpc.CallOption) (*ProcessManagerHandleResponse, error)
}

type processManagerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessManagerServiceClient(cc grpc.ClientConnInterface) ProcessManagerServiceClient {
	return &processManagerServiceClient{cc}
}

func (c *processManagerServiceClient) GetDescriptor(ctx context.Context, in *GetDescriptorRequest, opts ...grpc.CallOption) (*ComponentDescriptor, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ComponentDescriptor)
	err := c.cc.Invoke(ctx, ProcessManagerService_GetDescriptor_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processManagerServiceClient) Prepare(ctx context.Context, in *ProcessManagerPrepareRequest, opts ...grpc.CallOption) (*ProcessManagerPrepareResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessManagerPrepareResponse)
	err := c.cc.Invoke(ctx, ProcessManagerService_Prepare_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *processManagerServiceClient) Handle(ctx context.Context, in *ProcessManagerHandleRequest, opts ...grpc.CallOption) (*ProcessManagerHandleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessManagerHandleResponse)
	err := c.cc.Invoke(ctx, ProcessManagerService_Handle_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessManagerServiceServer is the server API for ProcessManagerService service.
// All implementations must embed UnimplementedProcessManagerServiceServer
// for forward compatibility.
//
// ProcessManagerService: stateful coordinator for long-running workflows across multiple aggregates.
//
// WARNING: Only use when saga + queries is insufficient. Consider:
// - Can a simple saga + destination queries solve this?
// - Is the "state" you want to track already derivable from existing aggregates?
// - Are you adding Process Manager because the workflow is genuinely complex?
//
// Process Manager is warranted when:
// - Workflow state is NOT derivable from aggregates (PM owns unique state)
// - You need to query workflow status independently ("show all pending fulfillments")
// - Timeout/scheduling logic is complex enough to merit its own aggregate
// - You must react to events from MULTIPLE domains (saga recommends single domain)
//
// Process Manager IS an aggregate with its own domain, events, and state.
// It reuses all aggregate infrastructure (EventStore, SnapshotStore, AggregateCoordinator).
type ProcessManagerServiceServer interface {
	// Self-description: component type, subscribed domains, handled event types
	GetDescriptor(context.Context, *GetDescriptorRequest) (*ComponentDescriptor, error)
	// Phase 1: Declare which additional destinations are needed beyond the trigger.
	// PM automatically receives triggering event's domain state.
	Prepare(context.Context, *ProcessManagerPrepareRequest) (*ProcessManagerPrepareResponse, error)
	// Phase 2: Handle with trigger + process state + fetched destinations.
	// Returns commands for other aggregates and events for the PM's own domain.
	Handle(context.Context, *ProcessManagerHandleRequest) (*ProcessManagerHandleResponse, error)
	mustEmbedUnimplementedProcessManagerServiceServer()
}

// UnimplementedProcessManagerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProcessManagerServiceServer struct{}

func (UnimplementedProcessManagerServiceServer) GetDescriptor(context.Context, *GetDescriptorRequest) (*ComponentDescriptor, error) {
	return nil, status.Error(codes.Unimplemented, "method GetDescriptor not implemented")
}
func (UnimplementedProcessManagerServiceServer) Prepare(context.Context, *ProcessManagerPrepareRequest) (*ProcessManagerPrepareResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Prepare not implemented")
}
func (UnimplementedProcessManagerServiceServer) Handle(context.Context, *ProcessManagerHandleRequest) (*ProcessManagerHandleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method Handle not implemented")
}
func (UnimplementedProcessManagerServiceServer) mustEmbedUnimplementedProcessManagerServiceServer() {}
func (UnimplementedProcessManagerServiceServer) testEmbeddedByValue()                               {}

// UnsafeProcessManagerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessManagerServiceServer will
// result in compilation errors.
type UnsafeProcessManagerServiceServer interface {
	mustEmbedUnimplementedProcessManagerServiceServer()
}

func RegisterProcessManagerServiceServer(s grpc.ServiceRegistrar, srv ProcessManagerServiceServer) {
	// If the following call panics, it indicates UnimplementedProcessManagerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProcessManagerService_ServiceDesc, srv)
}

func _ProcessManagerService_GetDescriptor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDescriptorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessManagerServiceServer).GetDescriptor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessManagerService_GetDescriptor_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessManagerServiceServer).GetDescriptor(ctx, req.(*GetDescriptorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessManagerService_Prepare_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessManagerPrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessManagerServiceServer).Prepare(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessManagerService_Prepare_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessManagerServiceServer).Prepare(ctx, req.(*ProcessManagerPrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ProcessManagerService_Handle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessManagerHandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessManagerServiceServer).Handle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessManagerService_Handle_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessManagerServiceServer).Handle(ctx, req.(*ProcessManagerHandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcessManagerService_ServiceDesc is the grpc.ServiceDesc for ProcessManagerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessManagerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "angzarr.ProcessManagerService",
	HandlerType: (*ProcessManagerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDescriptor",
			Handler:    _ProcessManagerService_GetDescriptor_Handler,
		},
		{
			MethodName: "Prepare",
			Handler:    _ProcessManagerService_Prepare_Handler,
		},
		{
			MethodName: "Handle",
			Handler:    _ProcessManagerService_Handle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "angzarr/process_manager.proto",
}

const (
	ProcessManagerCoordinatorService_HandleSpeculative_FullMethodName = "/angzarr.ProcessManagerCoordinatorService/HandleSpeculative"
)

// ProcessManagerCoordinatorServiceClient is the client API for ProcessManagerCoordinatorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// ProcessManagerCoordinatorService: orchestrates PM execution
type ProcessManagerCoordinatorServiceClient interface {
	// Speculative execution - returns commands and events without persisting
	HandleSpeculative(ctx context.Context, in *ProcessManagerHandleRequest, opts ...grpc.CallOption) (*ProcessManagerHandleResponse, error)
}

type processManagerCoordinatorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewProcessManagerCoordinatorServiceClient(cc grpc.ClientConnInterface) ProcessManagerCoordinatorServiceClient {
	return &processManagerCoordinatorServiceClient{cc}
}

func (c *processManagerCoordinatorServiceClient) HandleSpeculative(ctx context.Context, in *ProcessManagerHandleRequest, opts ...grpc.CallOption) (*ProcessManagerHandleResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessManagerHandleResponse)
	err := c.cc.Invoke(ctx, ProcessManagerCoordinatorService_HandleSpeculative_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProcessManagerCoordinatorServiceServer is the server API for ProcessManagerCoordinatorService service.
// All implementations must embed UnimplementedProcessManagerCoordinatorServiceServer
// for forward compatibility.
//
// ProcessManagerCoordinatorService: orchestrates PM execution
type ProcessManagerCoordinatorServiceServer interface {
	// Speculative execution - returns commands and events without persisting
	HandleSpeculative(context.Context, *ProcessManagerHandleRequest) (*ProcessManagerHandleResponse, error)
	mustEmbedUnimplementedProcessManagerCoordinatorServiceServer()
}

// UnimplementedProcessManagerCoordinatorServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedProcessManagerCoordinatorServiceServer struct{}

func (UnimplementedProcessManagerCoordinatorServiceServer) HandleSpeculative(context.Context, *ProcessManagerHandleRequest) (*ProcessManagerHandleResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method HandleSpeculative not implemented")
}
func (UnimplementedProcessManagerCoordinatorServiceServer) mustEmbedUnimplementedProcessManagerCoordinatorServiceServer() {
}
func (UnimplementedProcessManagerCoordinatorServiceServer) testEmbeddedByValue() {}

// UnsafeProcessManagerCoordinatorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProcessManagerCoordinatorServiceServer will
// result in compilation errors.
type UnsafeProcessManagerCoordinatorServiceServer interface {
	mustEmbedUnimplementedProcessManagerCoordinatorServiceServer()
}

func RegisterProcessManagerCoordinatorServiceServer(s grpc.ServiceRegistrar, srv ProcessManagerCoordinatorServiceServer) {
	// If the following call panics, it indicates UnimplementedProcessManagerCoordinatorServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ProcessManagerCoordinatorService_ServiceDesc, srv)
}

func _ProcessManagerCoordinatorService_HandleSpeculative_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessManagerHandleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProcessManagerCoordinatorServiceServer).HandleSpeculative(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ProcessManagerCoordinatorService_HandleSpeculative_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProcessManagerCoordinatorServiceServer).HandleSpeculative(ctx, req.(*ProcessManagerHandleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ProcessManagerCoordinatorService_ServiceDesc is the grpc.ServiceDesc for ProcessManagerCoordinatorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ProcessManagerCoordinatorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "angzarr.ProcessManagerCoordinatorService",
	HandlerType: (*ProcessManagerCoordinatorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "HandleSpeculative",
			Handler:    _ProcessManagerCoordinatorService_HandleSpeculative_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "angzarr/process_manager.proto",
}
