syntax = "proto3";
package angzarr;
option go_package = "github.com/angzarr/angzarr/proto/angzarr";
option java_package = "dev.angzarr";
option java_multiple_files = true;
option csharp_namespace = "Angzarr";
option ruby_package = "Angzarr";

import "angzarr/types.proto";
import "google/protobuf/any.proto";
import "google/protobuf/empty.proto";

// AggregateService: client logic that processes commands and emits events
// Also known as Command Handler in CQRS terminology
// client logic doesn't care about sync - coordinator decides
service AggregateService {
  // Self-description: component type, subscribed domains, handled command types
  rpc GetDescriptor (GetDescriptorRequest) returns (ComponentDescriptor);
  // Process command and return business response (events or revocation request)
  rpc Handle (ContextualCommand) returns (BusinessResponse);
  // Replay events to compute state (for conflict detection)
  // Optional: only needed if aggregate supports MERGE_COMMUTATIVE
  rpc Replay (ReplayRequest) returns (ReplayResponse);
}

// Request to replay events and compute resulting state
message ReplayRequest {
  Snapshot base_snapshot = 1;     // Starting state (empty = initial state)
  repeated EventPage events = 2;  // Events to apply in order
}

// Response with computed state after replay
message ReplayResponse {
  google.protobuf.Any state = 1;  // Resulting state
}

// AggregateCoordinatorService: orchestrates command processing for aggregates
service AggregateCoordinatorService {
  // Async processing - fire and forget
  rpc Handle (CommandBook) returns (CommandResponse);
  // Sync processing - waits for completion based on sync_mode
  rpc HandleSync (SyncCommandBook) returns (CommandResponse);
  // Speculative execution - execute against temporal state without persisting
  rpc HandleSyncSpeculative (SpeculateAggregateRequest) returns (CommandResponse);
}

// Response from entity - aggregate events + sync projector results
message CommandResponse {
  EventBook events = 1;               // Events from the target aggregate
  repeated Projection projections = 2; // Synchronous projector results
}

// client logic requests framework to handle revocation
message RevocationResponse {
  bool emit_system_revocation = 1;      // Emit SagaCompensationFailed event
  bool send_to_dead_letter_queue = 2;   // Send to DLQ
  bool escalate = 3;                    // Flag for alerting/human intervention
  bool abort = 4;                       // Stop saga chain, propagate error to caller
  string reason = 5;                    // Context/reason
}

// Wrapper response for BusinessLogic.Handle
message BusinessResponse {
  oneof result {
    EventBook events = 1;               // Business provides compensation events
    RevocationResponse revocation = 2;  // Business requests framework action
    Notification notification = 3;      // Forward rejection notification upstream
  }
}

// Request for speculative command execution against temporal state.
message SpeculateAggregateRequest {
  CommandBook command = 1;
  TemporalQuery point_in_time = 2;
}
