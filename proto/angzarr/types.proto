syntax = "proto3";
package angzarr;
option go_package = "github.com/angzarr/angzarr/proto/angzarr";
option java_package = "dev.angzarr";
option java_multiple_files = true;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

message UUID {
  bytes value = 1;
}

message Cover {
  string domain = 2;
  UUID root = 1;
  string correlation_id = 3;  // Workflow correlation - flows through all commands/events
  optional string edition = 4; // Edition name for diverged timelines; empty = main timeline
}

// Controls synchronous processing behavior
enum SyncMode {
  SYNC_MODE_NONE = 0;     // Async: fire and forget (default)
  SYNC_MODE_SIMPLE = 1;   // Sync projectors only, no saga cascade
  SYNC_MODE_CASCADE = 2;  // Full sync: projectors + saga cascade (expensive)
}

message EventPage {
  oneof sequence {
    uint32 num = 1;
    bool force = 2;
  }
  google.protobuf.Timestamp created_at = 3;
  google.protobuf.Any event = 4;
}

// Snapshot of aggregate state at a given sequence number.
// State must be a protobuf Message to serialize into Any.
message Snapshot {
  uint32 sequence = 2;
  google.protobuf.Any state = 3;
}

message EventBook {
  Cover cover = 1;
  Snapshot snapshot = 2;                    // Framework-populated when loading (has sequence)
  repeated EventPage pages = 3;
  // Field 4 removed: correlation_id moved to Cover
  // client logic sets this; framework computes sequence.
  // State must be a protobuf Message for serialization into Any.
  google.protobuf.Any snapshot_state = 5;
}

message SyncEventBook {
  EventBook events = 1;
  SyncMode sync_mode = 2;
}

message Projection {
  Cover cover = 1;
  string projector = 2;
  uint32 sequence = 3;
  google.protobuf.Any projection = 4;
}

// Response from entity - aggregate events + sync projector results
message CommandResponse {
  EventBook events = 1;               // Events from the target aggregate
  repeated Projection projections = 2; // Synchronous projector results
}

// Response from saga - commands for other aggregates
message SagaResponse {
  repeated CommandBook commands = 1;  // Commands to execute on other aggregates
  repeated EventBook events = 2;      // Events to publish directly
}

// Two-phase saga protocol messages
message SagaPrepareRequest {
  EventBook source = 1;  // Source events that triggered the saga
}

message SagaPrepareResponse {
  repeated Cover destinations = 1;  // Destination aggregates the saga needs to read
}

message SagaExecuteRequest {
  EventBook source = 1;             // Source events (same as prepare)
  repeated EventBook destinations = 2;  // Fetched destination state
}

message SagaRetryRequest {
  EventBook source = 1;
  repeated EventBook destinations = 2;
  CommandBook rejected_command = 3;
  string rejection_reason = 4;
  uint32 attempt = 5;
}

// Track saga command origin for compensation flow
message SagaCommandOrigin {
  string saga_name = 1;                 // Name of the saga that issued the command
  Cover triggering_aggregate = 2;       // Domain+root of aggregate that triggered the saga
  uint32 triggering_event_sequence = 3; // Sequence number of the triggering event
}

// Command sent to original aggregate when saga command is rejected
message RevokeEventCommand {
  uint32 triggering_event_sequence = 1; // Which event triggered the failed saga flow
  string saga_name = 2;                  // Saga that issued the rejected command
  string rejection_reason = 3;           // Why the command was rejected
  CommandBook rejected_command = 4;      // The command that was rejected
}

// client logic requests framework to handle revocation
message RevocationResponse {
  bool emit_system_revocation = 1;      // Emit SagaCompensationFailed event
  bool send_to_dead_letter_queue = 2;   // Send to DLQ
  bool escalate = 3;                    // Flag for alerting/human intervention
  bool abort = 4;                       // Stop saga chain, propagate error to caller
  string reason = 5;                    // Context/reason
}

// Wrapper response for BusinessLogic.Handle
message BusinessResponse {
  oneof result {
    EventBook events = 1;               // Business provides compensation events
    RevocationResponse revocation = 2;  // Business requests framework action
  }
}

// System event when compensation fails/requested
message SagaCompensationFailed {
  Cover triggering_aggregate = 1;
  uint32 triggering_event_sequence = 2;
  string saga_name = 3;
  string rejection_reason = 4;
  string compensation_failure_reason = 5;
  CommandBook rejected_command = 6;
  google.protobuf.Timestamp occurred_at = 7;
}

message CommandPage {
  // Expected sequence number for this command's events.
  // Must match the aggregate's current next sequence (i.e., events.len()).
  // For new aggregates, use 0.
  uint32 sequence = 1;
  google.protobuf.Any command = 3;
}

message CommandBook {
  Cover cover = 1;
  repeated CommandPage pages = 2;
  // Field 3 removed: correlation_id moved to Cover
  SagaCommandOrigin saga_origin = 4;  // Tracks origin for compensation flow
  // Field 5 removed: 'fact' was unused
}

message SyncCommandBook {
  CommandBook command = 1;
  SyncMode sync_mode = 2;
}

message ContextualCommand {
  // Passed from aggregate coordinator to aggregate, consists of everything needed to execute/evaluate the command
  EventBook events = 1;
  CommandBook command = 2;
}

message SyncContextualCommand {
  ContextualCommand command = 1;
  SyncMode sync_mode = 2;
}

// Query types
message SequenceRange {
  uint32 lower = 1;
  optional uint32 upper = 2;  // If not set, query to latest
}

message SequenceSet {
  repeated uint32 values = 1;
}

// Temporal query: retrieve aggregate state at a point in history.
// Replays events from sequence 0 (no snapshots) to the specified point.
message TemporalQuery {
  oneof point_in_time {
    google.protobuf.Timestamp as_of_time = 1;     // Events with created_at <= this
    uint32 as_of_sequence = 2;                     // Events with sequence <= this
  }
}

message Query {
  // Cover identifies the aggregate: domain + (root | correlation_id | both)
  // Query by root: Cover { domain, root }
  // Query by correlation: Cover { domain, correlation_id }
  Cover cover = 1;
  // Field 2 removed: now use cover.root
  oneof selection {
    SequenceRange range = 3;
    SequenceSet sequences = 4;
    TemporalQuery temporal = 5;
  }
}

message AggregateRoot {
  string domain = 1;
  UUID root = 2;
}

// Request for dry-run command execution against temporal state.
message DryRunRequest {
  CommandBook command = 1;
  TemporalQuery point_in_time = 2;
}

// Subscription filter for event streaming
message EventStreamFilter {
  string correlation_id = 1;
}
