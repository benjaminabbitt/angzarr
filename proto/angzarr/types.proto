// DOC: This file is referenced in docs/docs/reference/patterns.mdx
//      Update documentation when making changes to MergeStrategy, SyncMode,
//      Edition, SnapshotRetention, or Notification types.

syntax = "proto3";
package angzarr;
option go_package = "github.com/angzarr/angzarr/proto/angzarr";
option java_package = "dev.angzarr";
option java_multiple_files = true;
option csharp_namespace = "Angzarr";
option ruby_package = "Angzarr";

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";

message UUID {
  bytes value = 1;
}

message Cover {
  string domain = 2;
  UUID root = 1;
  string correlation_id = 3;  // Workflow correlation - flows through all commands/events
  Edition edition = 4;        // Edition for diverged timelines; empty name = main timeline
}

// Edition identifier with optional explicit divergence points.
//
// Two modes:
// - Implicit (divergences empty): Divergence derived from first edition event's sequence
// - Explicit (divergences populated): Per-domain divergence points for historical branching,
//  saga coordination, or speculative execution
message Edition {
  string name = 1;                              // Edition name, e.g., "v2"; empty = main timeline
  repeated DomainDivergence divergences = 2;   // Optional: explicit per-domain divergence points
}

// Explicit divergence point for a specific domain.
// Used when creating historical branches or coordinating saga writes across domains.
message DomainDivergence {
  string domain = 1;    // Domain name
  uint32 sequence = 2;  // Divergence sequence number
}

// Controls synchronous processing behavior
enum SyncMode {
  SYNC_MODE_UNSPECIFIED = 0;  // Async: fire and forget (default)
  SYNC_MODE_SIMPLE = 1;       // Sync projectors only, no saga cascade
  SYNC_MODE_CASCADE = 2;      // Full sync: projectors + saga cascade (expensive)
}

// Controls how concurrent commands to the same aggregate are handled
enum MergeStrategy {
  MERGE_COMMUTATIVE = 0;       // Default: allow if state field mutations don't overlap
  MERGE_STRICT = 1;            // Reject if sequence mismatch (optimistic concurrency)
  MERGE_AGGREGATE_HANDLES = 2; // Aggregate handles its own concurrency
  MERGE_MANUAL = 3;            // Send to DLQ for manual review on mismatch
}

// Controls snapshot retention during cleanup
enum SnapshotRetention {
  RETENTION_DEFAULT = 0;   // Persist every 16 events, treated as TRANSIENT otherwise
  RETENTION_PERSIST = 1;   // Keep indefinitely (business milestone)
  RETENTION_TRANSIENT = 2; // Delete when newer snapshot written
}

// Storage backend type for externally stored payloads (claim check pattern).
enum PayloadStorageType {
  PAYLOAD_STORAGE_TYPE_UNSPECIFIED = 0;
  PAYLOAD_STORAGE_TYPE_FILESYSTEM = 1;
  PAYLOAD_STORAGE_TYPE_GCS = 2;
  PAYLOAD_STORAGE_TYPE_S3 = 3;
}

// Reference to externally stored payload (claim check pattern).
// Used when event/command payloads exceed message bus size limits.
message PayloadReference {
  PayloadStorageType storage_type = 1;
  // Location URI:
  // - file:///var/angzarr/payloads/{hash}.bin
  // - gs://bucket/prefix/{hash}.bin
  // - s3://bucket/prefix/{hash}.bin
  string uri = 2;
  // Content hash for integrity verification and deduplication (SHA-256)
  bytes content_hash = 3;
  // Original serialized payload size in bytes
  uint64 original_size = 4;
  // Timestamp when payload was stored (for TTL cleanup)
  google.protobuf.Timestamp stored_at = 5;
}

message EventPage {
  uint32 sequence = 1;
  google.protobuf.Timestamp created_at = 2;
  oneof payload {
    google.protobuf.Any event = 3;
    PayloadReference external = 4;  // Claim check: payload stored externally
  }
}

// Snapshot of aggregate state at a given sequence number.
// State must be a protobuf Message to serialize into Any.
message Snapshot {
  uint32 sequence = 2;
  google.protobuf.Any state = 3;
  SnapshotRetention retention = 4; // Controls cleanup behavior
}

message EventBook {
  Cover cover = 1;
  Snapshot snapshot = 2;                    // Snapshot state; sequence computed by framework on persist
  repeated EventPage pages = 3;
  // Field 4 removed: correlation_id moved to Cover
  // Field 5 removed: snapshot_state unified into snapshot field
  uint32 next_sequence = 6;                 // Computed on load, never stored: (last page seq OR snapshot seq if no pages) + 1
}

message SyncEventBook {
  EventBook events = 1;
  SyncMode sync_mode = 2;
}

message Projection {
  Cover cover = 1;
  string projector = 2;
  uint32 sequence = 3;
  google.protobuf.Any projection = 4;
}

message CommandPage {
  // Expected sequence number for this command's events.
  // Must match the aggregate's current next sequence (i.e., events.len()).
  // For new aggregates, use 0.
  uint32 sequence = 1;
  MergeStrategy merge_strategy = 2;
  oneof payload {
    google.protobuf.Any command = 3;
    PayloadReference external = 4;  // Claim check: payload stored externally
  }
}

message CommandBook {
  Cover cover = 1;
  repeated CommandPage pages = 2;
  // Field 3 removed: correlation_id moved to Cover
  SagaCommandOrigin saga_origin = 4;  // Tracks origin for compensation flow
  // Field 5 removed: 'fact' was unused
}

message SyncCommandBook {
  CommandBook command = 1;
  SyncMode sync_mode = 2;
}

message ContextualCommand {
  // Passed from aggregate coordinator to aggregate, consists of everything needed to execute/evaluate the command
  EventBook events = 1;
  CommandBook command = 2;
}

message SyncContextualCommand {
  ContextualCommand command = 1;
  SyncMode sync_mode = 2;
}

// Query types
message SequenceRange {
  uint32 lower = 1;
  optional uint32 upper = 2;  // If not set, query to latest
}

message SequenceSet {
  repeated uint32 values = 1;
}

// Temporal query: retrieve aggregate state at a point in history.
// Replays events from sequence 0 (no snapshots) to the specified point.
message TemporalQuery {
  oneof point_in_time {
    google.protobuf.Timestamp as_of_time = 1;     // Events with created_at <= this
    uint32 as_of_sequence = 2;                     // Events with sequence <= this
  }
}

message Query {
  // Cover identifies the aggregate: domain + (root | correlation_id | both)
  // Query by root: Cover { domain, root }
  // Query by correlation: Cover { domain, correlation_id }
  Cover cover = 1;
  // Field 2 removed: now use cover.root
  oneof selection {
    SequenceRange range = 3;
    SequenceSet sequences = 4;
    TemporalQuery temporal = 5;
  }
}

message AggregateRoot {
  string domain = 1;
  UUID root = 2;
}

// Subscription filter for event streaming
message EventStreamFilter {
  string correlation_id = 1;
}

// Domain subscription with event types.
// Types are auto-derived from router registrations, never manually configured.
message Target {
  string domain = 1;
  repeated string types = 2;
}

// Self-description of a runtime component (aggregate, saga, projector, process_manager).
// Topology edges derived from inputs: if A subscribes to domain X, edge Xâ†’A exists.
message ComponentDescriptor {
  string name = 1;
  string component_type = 2;
  repeated Target inputs = 3;   // Domains I subscribe to (event types I consume)
}

// Request for GetDescriptor RPC.
message GetDescriptorRequest {}

// Track saga command origin for compensation flow
message SagaCommandOrigin {
  string saga_name = 1;                 // Name of the saga that issued the command
  Cover triggering_aggregate = 2;       // Domain+root of aggregate that triggered the saga
  uint32 triggering_event_sequence = 3; // Sequence number of the triggering event
}

// ============================================================================
// Notifications - Non-persisted messages for signaling
// ============================================================================
//
// Notifications differ from Events in key ways:
// - NOT persisted to event store (ephemeral)
// - NO sequence numbers (not ordered within an aggregate)
// - NO event sourcing replay (fire-and-forget)
// - Used for: compensation signals, real-time alerts, system warnings
//
// Notifications reuse Cover for routing (domain, root, correlation_id) but
// lack EventPage's sequence semantics.

// Base notification message for transient system signals.
// Contains routing info via Cover but no persistence semantics.
// Type discrimination via payload.type_url (standard Any behavior).
message Notification {
  Cover cover = 1;                          // Routing: domain, root, correlation_id
  google.protobuf.Any payload = 2;          // Type-specific content (RejectionNotification, etc.)
  google.protobuf.Timestamp sent_at = 3;    // When notification was created
  map<string, string> metadata = 4;         // Optional key-value metadata
}

// Notification payload for command rejection scenarios.
// Embedded in Notification.payload when a saga/PM command is rejected.
message RejectionNotification {
  CommandBook rejected_command = 1;         // The command that was rejected (full context)
  string rejection_reason = 2;              // Why: "insufficient_funds", "out_of_stock", etc.
  string issuer_name = 3;                   // Saga/PM name that issued the command
  string issuer_type = 4;                   // "saga" | "process_manager"
  Cover source_aggregate = 5;               // Aggregate that originally triggered the flow
  uint32 source_event_sequence = 6;         // Event sequence that triggered the saga/PM
}

// ============================================================================
// Dead Letter Queue (DLQ) Messages
// ============================================================================

// Sequence mismatch details for DLQ entries.
// Contains expected vs actual sequence for debugging and replay.
message SequenceMismatchDetails {
  uint32 expected_sequence = 1;         // What the command expected
  uint32 actual_sequence = 2;           // What the aggregate was at
  MergeStrategy merge_strategy = 3;     // Strategy that triggered DLQ routing
}

// Event processing failure details for DLQ entries.
// Contains information about why a saga/projector failed to process events.
message EventProcessingFailedDetails {
  string error = 1;                     // Error message from the handler
  uint32 retry_count = 2;               // Number of retry attempts before DLQ routing
  bool is_transient = 3;                // Whether the failure is considered transient
}

// Payload retrieval failure details for DLQ entries.
// Contains information about why an externally stored payload couldn't be retrieved.
message PayloadRetrievalFailedDetails {
  PayloadStorageType storage_type = 1;  // Storage backend type
  string uri = 2;                       // URI of the payload that couldn't be retrieved
  bytes content_hash = 3;               // Content hash for identification
  uint64 original_size = 4;             // Original payload size in bytes
  string error = 5;                     // Error message from the retrieval attempt
}

// Dead letter queue entry for failed messages requiring manual intervention.
// Per-domain topics: angzarr.dlq.{domain}
message AngzarrDeadLetter {
  Cover cover = 1;                      // Routing: domain, root, correlation_id
  oneof payload {
    CommandBook rejected_command = 2;   // Command that failed
    EventBook rejected_events = 9;      // Events that failed (saga/projector failures)
  }
  string rejection_reason = 3;          // Human-readable reason
  oneof rejection_details {
    SequenceMismatchDetails sequence_mismatch = 12;          // Sequence conflict details
    EventProcessingFailedDetails event_processing_failed = 13; // Handler failure details
    PayloadRetrievalFailedDetails payload_retrieval_failed = 14; // Payload store failure details
  }
  google.protobuf.Timestamp occurred_at = 7;
  map<string, string> metadata = 8;     // Additional context
  string source_component = 10;         // Which component sent to DLQ
  string source_component_type = 11;    // "aggregate" | "saga" | "projector" | "process_manager"
}
