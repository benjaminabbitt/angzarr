syntax = "proto3";
package angzarr;
option go_package = "github.com/angzarr/angzarr/proto/angzarr";
option java_package = "dev.angzarr";
option java_multiple_files = true;

import "google/protobuf/any.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

message UUID {
  bytes value = 1;
}

message Cover {
  string domain = 2;
  UUID root = 1;
}

message EventPage {
  oneof sequence {
    uint32 num = 1;
    bool force = 2;
  }
  google.protobuf.Timestamp created_at = 3;
  google.protobuf.Any event = 4;
  bool synchronous = 5;
}

message Snapshot {
  uint32 sequence = 2;
  google.protobuf.Any state = 3;
}

message EventBook {
  Cover cover = 1;
  Snapshot snapshot = 2;                    // Framework-populated when loading (has sequence)
  repeated EventPage pages = 3;
  string correlation_id = 4;
  google.protobuf.Any snapshot_state = 5;   // Business logic sets this; framework computes sequence
}

message Projection {
  Cover cover = 1;
  string projector = 2;
  uint32 sequence = 3;
  google.protobuf.Any projection = 4;
}

// Response from entity - aggregate events + sync projector results
message CommandResponse {
  EventBook events = 1;               // Events from the target aggregate
  repeated Projection projections = 2; // Synchronous projector results
}

// Response from saga - commands for other aggregates
message SagaResponse {
  repeated CommandBook commands = 1;  // Commands to execute on other aggregates
}

// Track saga command origin for compensation flow
message SagaCommandOrigin {
  string saga_name = 1;                 // Name of the saga that issued the command
  Cover triggering_aggregate = 2;       // Domain+root of aggregate that triggered the saga
  uint32 triggering_event_sequence = 3; // Sequence number of the triggering event
}

// Command sent to original aggregate when saga command is rejected
message RevokeEventCommand {
  uint32 triggering_event_sequence = 1; // Which event triggered the failed saga flow
  string saga_name = 2;                  // Saga that issued the rejected command
  string rejection_reason = 3;           // Why the command was rejected
  CommandBook rejected_command = 4;      // The command that was rejected
}

// Business logic requests framework to handle revocation
message RevocationResponse {
  bool emit_system_revocation = 1;      // Emit SagaCompensationFailed event
  bool send_to_dead_letter_queue = 2;   // Send to DLQ
  bool escalate = 3;                    // Flag for alerting/human intervention
  bool abort = 4;                       // Stop saga chain, propagate error to caller
  string reason = 5;                    // Context/reason
}

// Wrapper response for BusinessLogic.Handle
message BusinessResponse {
  oneof result {
    EventBook events = 1;               // Business provides compensation events
    RevocationResponse revocation = 2;  // Business requests framework action
  }
}

// System event when compensation fails/requested
message SagaCompensationFailed {
  Cover triggering_aggregate = 1;
  uint32 triggering_event_sequence = 2;
  string saga_name = 3;
  string rejection_reason = 4;
  string compensation_failure_reason = 5;
  CommandBook rejected_command = 6;
  google.protobuf.Timestamp occurred_at = 7;
}

message CommandPage {
  uint32 sequence = 1;
  bool synchronous = 2;
  google.protobuf.Any command = 3;
}

message CommandBook {
  Cover cover = 1;
  repeated CommandPage pages = 2;
  string correlation_id = 3;
  SagaCommandOrigin saga_origin = 4;  // Tracks origin for compensation flow
  bool auto_resequence = 5;           // Retry on sequence conflicts
  bool fact = 6;                      // Business logic should try hard to succeed
}

message ContextualCommand {
  // Passed from entity to business logic, consists of everything needed to execute/evaluate the command
  EventBook events = 1;
  CommandBook command = 2;
}

service BusinessLogic {
  rpc Handle (angzarr.ContextualCommand) returns (angzarr.BusinessResponse) {
  }
}

service BusinessCoordinator {
  rpc Handle (angzarr.CommandBook) returns (angzarr.CommandResponse) {
  }
  rpc Record (angzarr.EventBook) returns (angzarr.CommandResponse) {
  }
}

service ProjectorCoordinator {
  rpc HandleSync (angzarr.EventBook) returns (angzarr.Projection) {
  }
  rpc Handle (angzarr.EventBook) returns (google.protobuf.Empty) {
  }
}

service Projector {
  rpc Handle (angzarr.EventBook) returns (google.protobuf.Empty) {
  }
  rpc HandleSync (angzarr.EventBook) returns (angzarr.Projection) {
  }
}

service EventQuery {
  // Get a single EventBook (unary) - use for explicit queries with gRPC tooling
  rpc GetEventBook (Query) returns (angzarr.EventBook) {
  }
  // Stream EventBooks matching query - use for bulk retrieval
  rpc GetEvents (Query) returns (stream angzarr.EventBook) {
  }
  rpc Synchronize (stream Query) returns (stream angzarr.EventBook) {
  }
  rpc GetAggregateRoots (google.protobuf.Empty) returns (stream AggregateRoot) {
  }
}
message Query {
  string domain = 1;
  angzarr.UUID root = 2;
  uint32 lower_bound = 3;
  uint32 upper_bound = 4;
}

message AggregateRoot {
  string domain = 1;
  angzarr.UUID root = 2;
}

service SagaCoordinator {
  rpc Handle (angzarr.EventBook) returns (google.protobuf.Empty) {
  }
  rpc HandleSync (angzarr.EventBook) returns (angzarr.SagaResponse) {
  }
}

service Saga {
  rpc Handle (angzarr.EventBook) returns (google.protobuf.Empty) {
  }
  rpc HandleSync (angzarr.EventBook) returns (angzarr.SagaResponse) {
  }
}

// Subscription filter for event streaming
message EventStreamFilter {
  string correlation_id = 1;
}

// Event stream service - streams events to registered subscribers
service EventStream {
  // Subscribe to events matching correlation ID (required)
  // Returns INVALID_ARGUMENT if correlation_id is empty
  rpc Subscribe (EventStreamFilter) returns (stream EventBook) {
  }
}

// Request for count-limited streaming
message ExecuteStreamCountRequest {
  CommandBook command = 1;
  int32 count = 2;  // 0 = unlimited
}

// Request for time-limited streaming
message ExecuteStreamTimeRequest {
  CommandBook command = 1;
  int32 timeout_ms = 2;  // milliseconds to stream
}

// Gateway service - send command and receive resulting events
service CommandGateway {
  // Send command, receive single response (unary)
  // Waits for command processing to complete, returns immediate events only
  rpc Execute (CommandBook) returns (CommandResponse) {}

  // Send command, stream events indefinitely until client disconnects or timeout
  rpc ExecuteStream (CommandBook) returns (stream EventBook) {}

  // Send command, stream until count responses received (0 = unlimited)
  rpc ExecuteStreamResponseCount (ExecuteStreamCountRequest) returns (stream EventBook) {}

  // Send command, stream for specified duration in milliseconds
  rpc ExecuteStreamResponseTime (ExecuteStreamTimeRequest) returns (stream EventBook) {}
}